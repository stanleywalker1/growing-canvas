"use strict";Object.defineProperty(exports, "__esModule", {value: true});var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
var __objRest = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};
var __async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};

// src/lib/EventSource.ts
function makeEventSource() {
  const _onetimeObservers = /* @__PURE__ */ new Set();
  const _observers = /* @__PURE__ */ new Set();
  function subscribe(callback) {
    _observers.add(callback);
    return () => _observers.delete(callback);
  }
  function subscribeOnce(callback) {
    _onetimeObservers.add(callback);
    return () => _onetimeObservers.delete(callback);
  }
  function notify(event) {
    _onetimeObservers.forEach((callback) => callback(event));
    _onetimeObservers.clear();
    _observers.forEach((callback) => callback(event));
  }
  function clear() {
    _onetimeObservers.clear();
    _observers.clear();
  }
  return {
    // Private/internal control over event emission
    notify,
    subscribe,
    subscribeOnce,
    clear,
    // Publicly exposable subscription API
    observable: {
      subscribe,
      subscribeOnce
    }
  };
}

// src/devtools/bridge.ts
var _bridgeActive = false;
function activateBridge(allowed) {
  _bridgeActive = allowed;
}
function sendToPanel(message, options) {
  if (process.env.NODE_ENV === "production" || typeof window === "undefined") {
    return;
  }
  const fullMsg = __spreadProps(__spreadValues({}, message), {
    source: "liveblocks-devtools-client"
  });
  if (!((options == null ? void 0 : options.force) || _bridgeActive)) {
    return;
  }
  window.postMessage(fullMsg, "*");
}
var eventSource = makeEventSource();
if (process.env.NODE_ENV !== "production" && typeof window !== "undefined") {
  window.addEventListener("message", (event) => {
    var _a;
    if (event.source === window && ((_a = event.data) == null ? void 0 : _a.source) === "liveblocks-devtools-panel") {
      eventSource.notify(event.data);
    } else {
    }
  });
}
var onMessageFromPanel = eventSource.observable;

// src/devtools/index.ts
var VERSION = true ? (
  /* istanbul ignore next */
  "1.0.8"
) : "dev";
var _devtoolsSetupHasRun = false;
function setupDevTools(getAllRooms) {
  if (process.env.NODE_ENV === "production" || typeof window === "undefined") {
    return;
  }
  if (_devtoolsSetupHasRun) {
    return;
  }
  _devtoolsSetupHasRun = true;
  onMessageFromPanel.subscribe((msg) => {
    switch (msg.msg) {
      case "connect": {
        activateBridge(true);
        for (const roomId of getAllRooms()) {
          sendToPanel({
            msg: "room::available",
            roomId,
            clientVersion: VERSION
          });
        }
        break;
      }
    }
  });
  sendToPanel({ msg: "wake-up-devtools" }, { force: true });
}
var unsubsByRoomId = /* @__PURE__ */ new Map();
function stopSyncStream(roomId) {
  var _a;
  const unsubs = (_a = unsubsByRoomId.get(roomId)) != null ? _a : [];
  unsubsByRoomId.delete(roomId);
  for (const unsub of unsubs) {
    unsub();
  }
}
function startSyncStream(room) {
  stopSyncStream(room.id);
  fullSync(room);
  unsubsByRoomId.set(room.id, [
    // When the connection status changes
    room.events.connection.subscribe(() => partialSyncConnection(room)),
    // When storage initializes, send the update
    room.events.storageDidLoad.subscribeOnce(() => partialSyncStorage(room)),
    // Any time storage updates, send the new storage root
    room.events.storage.subscribe(() => partialSyncStorage(room)),
    // Any time "me" or "others" updates, send the new values accordingly
    room.events.me.subscribe(() => partialSyncMe(room)),
    room.events.others.subscribe(() => partialSyncOthers(room))
  ]);
}
function partialSyncConnection(room) {
  sendToPanel({
    msg: "room::sync::partial",
    roomId: room.id,
    status: room.getConnectionState()
  });
}
function partialSyncStorage(room) {
  const root = room.getStorageSnapshot();
  if (root) {
    sendToPanel({
      msg: "room::sync::partial",
      roomId: room.id,
      storage: root.toTreeNode("root").payload
    });
  }
}
function partialSyncMe(room) {
  const me = room.__internal.getSelf_forDevTools();
  if (me) {
    sendToPanel({
      msg: "room::sync::partial",
      roomId: room.id,
      me
    });
  }
}
function partialSyncOthers(room) {
  const others = room.__internal.getOthers_forDevTools();
  if (others) {
    sendToPanel({
      msg: "room::sync::partial",
      roomId: room.id,
      others
    });
  }
}
function fullSync(room) {
  var _a;
  const root = room.getStorageSnapshot();
  const me = room.__internal.getSelf_forDevTools();
  const others = room.__internal.getOthers_forDevTools();
  sendToPanel({
    msg: "room::sync::full",
    roomId: room.id,
    status: room.getConnectionState(),
    storage: (_a = root == null ? void 0 : root.toTreeNode("root").payload) != null ? _a : null,
    me,
    others
  });
}
var roomChannelListeners = /* @__PURE__ */ new Map();
function stopRoomChannelListener(roomId) {
  const listener = roomChannelListeners.get(roomId);
  roomChannelListeners.delete(roomId);
  if (listener) {
    listener();
  }
}
function linkDevTools(roomId, room) {
  if (process.env.NODE_ENV === "production" || typeof window === "undefined") {
    return;
  }
  sendToPanel({ msg: "room::available", roomId, clientVersion: VERSION });
  stopRoomChannelListener(roomId);
  roomChannelListeners.set(
    roomId,
    // Returns the unsubscribe callback, that we store in the
    // roomChannelListeners registry
    onMessageFromPanel.subscribe((msg) => {
      switch (msg.msg) {
        case "room::subscribe": {
          if (msg.roomId === roomId) {
            startSyncStream(room);
          }
          break;
        }
        case "room::unsubscribe": {
          if (msg.roomId === roomId) {
            stopSyncStream(roomId);
          }
          break;
        }
      }
    })
  );
}
function unlinkDevTools(roomId) {
  if (process.env.NODE_ENV === "production" || typeof window === "undefined") {
    return;
  }
  stopSyncStream(roomId);
  stopRoomChannelListener(roomId);
  sendToPanel({
    msg: "room::unavailable",
    roomId
  });
}

// src/lib/fancy-console.ts
var badge = "background:#0e0d12;border-radius:9999px;color:#fff;padding:3px 7px;font-family:sans-serif;font-weight:600;";
var bold = "font-weight:600";
function wrap(method) {
  return typeof window === "undefined" || process.env.NODE_ENV === "test" ? console[method] : (
    /* istanbul ignore next */
    (message, ...args) => console[method]("%cLiveblocks", badge, message, ...args)
  );
}
var warn = wrap("warn");
var error = wrap("error");
function wrapWithTitle(method) {
  return typeof window === "undefined" || process.env.NODE_ENV === "test" ? console[method] : (
    /* istanbul ignore next */
    (title, message, ...args) => console[method](
      `%cLiveblocks%c ${title}`,
      badge,
      bold,
      message,
      ...args
    )
  );
}
var warnWithTitle = wrapWithTitle("warn");
var errorWithTitle = wrapWithTitle("error");

// src/lib/deprecation.ts
var _emittedDeprecationWarnings = /* @__PURE__ */ new Set();
function deprecate(message, key = message) {
  if (process.env.NODE_ENV !== "production") {
    if (!_emittedDeprecationWarnings.has(key)) {
      _emittedDeprecationWarnings.add(key);
      errorWithTitle("Deprecation warning", message);
    }
  }
}
function deprecateIf(condition, message, key = message) {
  if (process.env.NODE_ENV !== "production") {
    if (condition) {
      deprecate(message, key);
    }
  }
}
function throwUsageError(message) {
  if (process.env.NODE_ENV !== "production") {
    const usageError = new Error(message);
    usageError.name = "Usage error";
    errorWithTitle("Usage error", message);
    throw usageError;
  }
}
function errorIf(condition, message) {
  if (process.env.NODE_ENV !== "production") {
    if (condition) {
      throwUsageError(message);
    }
  }
}

// src/lib/assert.ts
function assertNever(_value, errmsg) {
  throw new Error(errmsg);
}
function assert(condition, errmsg) {
  if (process.env.NODE_ENV !== "production") {
    if (!condition) {
      const err = new Error(errmsg);
      err.name = "Assertion failure";
      throw err;
    }
  }
}
function nn(value, errmsg = "Expected value to be non-nullable") {
  assert(value !== null && value !== void 0, errmsg);
  return value;
}

// src/lib/position.ts
var MIN_CODE = 32;
var MAX_CODE = 126;
var NUM_DIGITS = MAX_CODE - MIN_CODE + 1;
var ZERO = nthDigit(0);
var ONE = nthDigit(1);
var ZERO_NINE = ZERO + nthDigit(-1);
function nthDigit(n) {
  const code = MIN_CODE + (n < 0 ? NUM_DIGITS + n : n);
  if (code < MIN_CODE || code > MAX_CODE) {
    throw new Error(`Invalid n value: ${n}`);
  }
  return String.fromCharCode(code);
}
function makePosition(x, y) {
  if (x !== void 0 && y !== void 0) {
    return between(x, y);
  } else if (x !== void 0) {
    return after(x);
  } else if (y !== void 0) {
    return before(y);
  } else {
    return ONE;
  }
}
function before(pos) {
  const lastIndex = pos.length - 1;
  for (let i = 0; i <= lastIndex; i++) {
    const code = pos.charCodeAt(i);
    if (code <= MIN_CODE) {
      continue;
    }
    if (i === lastIndex) {
      if (code === MIN_CODE + 1) {
        return pos.substring(0, i) + ZERO_NINE;
      } else {
        return pos.substring(0, i) + String.fromCharCode(code - 1);
      }
    } else {
      return pos.substring(0, i + 1);
    }
  }
  return ONE;
}
function after(pos) {
  for (let i = 0; i <= pos.length - 1; i++) {
    const code = pos.charCodeAt(i);
    if (code >= MAX_CODE) {
      continue;
    }
    return pos.substring(0, i) + String.fromCharCode(code + 1);
  }
  return pos + ONE;
}
function between(lo, hi) {
  if (lo < hi) {
    return _between(lo, hi);
  } else if (lo > hi) {
    return _between(hi, lo);
  } else {
    throw new Error("Cannot compute value between two equal positions");
  }
}
function _between(lo, hi) {
  let index = 0;
  const loLen = lo.length;
  const hiLen = hi.length;
  while (true) {
    const loCode = index < loLen ? lo.charCodeAt(index) : MIN_CODE;
    const hiCode = index < hiLen ? hi.charCodeAt(index) : MAX_CODE;
    if (loCode === hiCode) {
      index++;
      continue;
    }
    if (hiCode - loCode === 1) {
      const prefix = lo.substring(0, index + 1);
      const suffix = lo.substring(index + 1);
      const nines = "";
      return prefix + _between(suffix, nines);
    } else {
      return takeN(lo, index) + String.fromCharCode(hiCode + loCode >> 1);
    }
  }
}
function takeN(pos, n) {
  return n < pos.length ? pos.substring(0, n) : pos + ZERO.repeat(n - pos.length);
}
var MIN_NON_ZERO_CODE = MIN_CODE + 1;
function isPos(str) {
  if (str === "") {
    return false;
  }
  const lastIdx = str.length - 1;
  const last = str.charCodeAt(lastIdx);
  if (last < MIN_NON_ZERO_CODE || last > MAX_CODE) {
    return false;
  }
  for (let i = 0; i < lastIdx; i++) {
    const code = str.charCodeAt(i);
    if (code < MIN_CODE || code > MAX_CODE) {
      return false;
    }
  }
  return true;
}
function convertToPos(str) {
  const codes = [];
  for (let i = 0; i < str.length; i++) {
    const code = str.charCodeAt(i);
    codes.push(code < MIN_CODE ? MIN_CODE : code > MAX_CODE ? MAX_CODE : code);
  }
  while (codes.length > 0 && codes[codes.length - 1] === MIN_CODE) {
    codes.length--;
  }
  return codes.length > 0 ? String.fromCharCode(...codes) : (
    // Edge case: the str was a 0-only string, which is invalid. Default back to .1
    ONE
  );
}
function asPos(str) {
  return isPos(str) ? str : convertToPos(str);
}

// src/protocol/Op.ts
var OpCode = /* @__PURE__ */ ((OpCode2) => {
  OpCode2[OpCode2["INIT"] = 0] = "INIT";
  OpCode2[OpCode2["SET_PARENT_KEY"] = 1] = "SET_PARENT_KEY";
  OpCode2[OpCode2["CREATE_LIST"] = 2] = "CREATE_LIST";
  OpCode2[OpCode2["UPDATE_OBJECT"] = 3] = "UPDATE_OBJECT";
  OpCode2[OpCode2["CREATE_OBJECT"] = 4] = "CREATE_OBJECT";
  OpCode2[OpCode2["DELETE_CRDT"] = 5] = "DELETE_CRDT";
  OpCode2[OpCode2["DELETE_OBJECT_KEY"] = 6] = "DELETE_OBJECT_KEY";
  OpCode2[OpCode2["CREATE_MAP"] = 7] = "CREATE_MAP";
  OpCode2[OpCode2["CREATE_REGISTER"] = 8] = "CREATE_REGISTER";
  return OpCode2;
})(OpCode || {});
function isAckOp(op) {
  return op.type === 5 /* DELETE_CRDT */ && op.id === "ACK";
}

// src/crdts/AbstractCrdt.ts
function crdtAsLiveNode(value) {
  return value;
}
function HasParent(node, key, pos = asPos(key)) {
  return Object.freeze({ type: "HasParent", node, key, pos });
}
var NoParent = Object.freeze({ type: "NoParent" });
function Orphaned(oldKey, oldPos = asPos(oldKey)) {
  return Object.freeze({ type: "Orphaned", oldKey, oldPos });
}
var AbstractCrdt = class {
  constructor() {
    /** @internal */
    this._parent = NoParent;
  }
  /** @internal */
  _getParentKeyOrThrow() {
    switch (this.parent.type) {
      case "HasParent":
        return this.parent.key;
      case "NoParent":
        throw new Error("Parent key is missing");
      case "Orphaned":
        return this.parent.oldKey;
      default:
        return assertNever(this.parent, "Unknown state");
    }
  }
  /** @internal */
  get _parentPos() {
    switch (this.parent.type) {
      case "HasParent":
        return this.parent.pos;
      case "NoParent":
        throw new Error("Parent key is missing");
      case "Orphaned":
        return this.parent.oldPos;
      default:
        return assertNever(this.parent, "Unknown state");
    }
  }
  /** @internal */
  get _pool() {
    return this.__pool;
  }
  get roomId() {
    return this.__pool ? this.__pool.roomId : null;
  }
  /** @internal */
  get _id() {
    return this.__id;
  }
  /** @internal */
  get parent() {
    return this._parent;
  }
  /** @internal */
  get _parentKey() {
    switch (this.parent.type) {
      case "HasParent":
        return this.parent.key;
      case "NoParent":
        return null;
      case "Orphaned":
        return this.parent.oldKey;
      default:
        return assertNever(this.parent, "Unknown state");
    }
  }
  /** @internal */
  _apply(op, _isLocal) {
    switch (op.type) {
      case 5 /* DELETE_CRDT */: {
        if (this.parent.type === "HasParent") {
          return this.parent.node._detachChild(crdtAsLiveNode(this));
        }
        return { modified: false };
      }
    }
    return { modified: false };
  }
  /** @internal */
  _setParentLink(newParentNode, newParentKey) {
    switch (this.parent.type) {
      case "HasParent":
        if (this.parent.node !== newParentNode) {
          throw new Error("Cannot set parent: node already has a parent");
        } else {
          this._parent = HasParent(newParentNode, newParentKey);
          return;
        }
      case "Orphaned":
      case "NoParent": {
        this._parent = HasParent(newParentNode, newParentKey);
        return;
      }
      default:
        return assertNever(this.parent, "Unknown state");
    }
  }
  /** @internal */
  _attach(id, pool) {
    if (this.__id || this.__pool) {
      throw new Error("Cannot attach node: already attached");
    }
    pool.addNode(id, crdtAsLiveNode(this));
    this.__id = id;
    this.__pool = pool;
  }
  /** @internal */
  _detach() {
    if (this.__pool && this.__id) {
      this.__pool.deleteNode(this.__id);
    }
    switch (this.parent.type) {
      case "HasParent": {
        this._parent = Orphaned(this.parent.key, this.parent.pos);
        break;
      }
      case "NoParent": {
        this._parent = NoParent;
        break;
      }
      case "Orphaned": {
        break;
      }
      default:
        assertNever(this.parent, "Unknown state");
    }
    this.__pool = void 0;
  }
  /**
   * @internal
   *
   * Clear the Immutable cache, so that the next call to `.toImmutable()` will
   * recompute the equivalent Immutable value again.  Call this after every
   * mutation to the Live node.
   */
  invalidate() {
    if (this._cachedImmutable !== void 0 || this._cachedTreeNode !== void 0) {
      this._cachedImmutable = void 0;
      this._cachedTreeNode = void 0;
      if (this.parent.type === "HasParent") {
        this.parent.node.invalidate();
      }
    }
  }
  /**
   * @internal
   *
   * Return an snapshot of this Live tree for use in DevTools.
   */
  toTreeNode(key) {
    if (this._cachedTreeNode === void 0 || this._cachedTreeNodeKey !== key) {
      this._cachedTreeNodeKey = key;
      this._cachedTreeNode = this._toTreeNode(key);
    }
    return this._cachedTreeNode;
  }
  /**
   * Return an immutable snapshot of this Live node and its children.
   */
  toImmutable() {
    if (this._cachedImmutable === void 0) {
      this._cachedImmutable = this._toImmutable();
    }
    return this._cachedImmutable;
  }
};

// src/lib/utils.ts
function isPlainObject(blob) {
  return blob !== null && typeof blob === "object" && Object.prototype.toString.call(blob) === "[object Object]";
}
function fromEntries(iterable) {
  const obj = {};
  for (const [key, val] of iterable) {
    obj[key] = val;
  }
  return obj;
}
function entries(obj) {
  return Object.entries(obj);
}
function tryParseJson(rawMessage) {
  try {
    return JSON.parse(rawMessage);
  } catch (e) {
    return void 0;
  }
}
function b64decode(b64value) {
  try {
    const formattedValue = b64value.replace(/-/g, "+").replace(/_/g, "/");
    const decodedValue = decodeURIComponent(
      atob(formattedValue).split("").map(function(c) {
        return "%" + ("00" + c.charCodeAt(0).toString(16)).slice(-2);
      }).join("")
    );
    return decodedValue;
  } catch (err) {
    return atob(b64value);
  }
}
function compact(items) {
  return items.filter(
    (item) => item !== null && item !== void 0
  );
}
function compactObject(obj) {
  const newObj = __spreadValues({}, obj);
  Object.keys(obj).forEach((k) => {
    const key = k;
    if (newObj[key] === void 0) {
      delete newObj[key];
    }
  });
  return newObj;
}

// src/protocol/SerializedCrdt.ts
var CrdtType = /* @__PURE__ */ ((CrdtType2) => {
  CrdtType2[CrdtType2["OBJECT"] = 0] = "OBJECT";
  CrdtType2[CrdtType2["LIST"] = 1] = "LIST";
  CrdtType2[CrdtType2["MAP"] = 2] = "MAP";
  CrdtType2[CrdtType2["REGISTER"] = 3] = "REGISTER";
  return CrdtType2;
})(CrdtType || {});
function isRootCrdt(crdt) {
  return crdt.type === 0 /* OBJECT */ && !isChildCrdt(crdt);
}
function isChildCrdt(crdt) {
  return crdt.parentId !== void 0 && crdt.parentKey !== void 0;
}

// src/lib/nanoid.ts
function nanoid(length = 7) {
  const alphabet = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789,./;[]~!@#$%&*()_+=-";
  const len = alphabet.length;
  return Array.from(
    { length },
    () => alphabet.charAt(Math.floor(Math.random() * len))
  ).join("");
}

// src/crdts/LiveRegister.ts
var LiveRegister = class extends AbstractCrdt {
  constructor(data) {
    super();
    this._data = data;
  }
  get data() {
    return this._data;
  }
  /** @internal */
  static _deserialize([id, item], _parentToChildren, pool) {
    const register = new LiveRegister(item.data);
    register._attach(id, pool);
    return register;
  }
  /** @internal */
  _toOps(parentId, parentKey, pool) {
    if (this._id === void 0) {
      throw new Error(
        "Cannot serialize register if parentId or parentKey is undefined"
      );
    }
    return [
      {
        type: 8 /* CREATE_REGISTER */,
        opId: pool == null ? void 0 : pool.generateOpId(),
        id: this._id,
        parentId,
        parentKey,
        data: this.data
      }
    ];
  }
  /** @internal */
  _serialize() {
    if (this.parent.type !== "HasParent") {
      throw new Error("Cannot serialize LiveRegister if parent is missing");
    }
    return {
      type: 3 /* REGISTER */,
      parentId: nn(this.parent.node._id, "Parent node expected to have ID"),
      parentKey: this.parent.key,
      data: this.data
    };
  }
  /** @internal */
  _attachChild(_op) {
    throw new Error("Method not implemented.");
  }
  /** @internal */
  _detachChild(_crdt) {
    throw new Error("Method not implemented.");
  }
  /** @internal */
  _apply(op, isLocal) {
    return super._apply(op, isLocal);
  }
  /** @internal */
  _toTreeNode(key) {
    var _a;
    return {
      type: "Json",
      id: (_a = this._id) != null ? _a : nanoid(),
      key,
      payload: this._data
    };
  }
  /** @internal */
  _toImmutable() {
    return this._data;
  }
};

// src/crdts/LiveList.ts
function compareNodePosition(itemA, itemB) {
  const posA = itemA._parentPos;
  const posB = itemB._parentPos;
  return posA === posB ? 0 : posA < posB ? -1 : 1;
}
var LiveList = class extends AbstractCrdt {
  constructor(items = []) {
    super();
    this._items = [];
    this._implicitlyDeletedItems = /* @__PURE__ */ new WeakSet();
    this._unacknowledgedSets = /* @__PURE__ */ new Map();
    let position = void 0;
    for (const item of items) {
      const newPosition = makePosition(position);
      const node = lsonToLiveNode(item);
      node._setParentLink(this, newPosition);
      this._items.push(node);
      position = newPosition;
    }
  }
  /** @internal */
  static _deserialize([id], parentToChildren, pool) {
    const list = new LiveList();
    list._attach(id, pool);
    const children = parentToChildren.get(id);
    if (children === void 0) {
      return list;
    }
    for (const [id2, crdt] of children) {
      const child = deserialize([id2, crdt], parentToChildren, pool);
      child._setParentLink(list, crdt.parentKey);
      list._insertAndSort(child);
    }
    return list;
  }
  /** @internal */
  _toOps(parentId, parentKey, pool) {
    if (this._id === void 0) {
      throw new Error("Cannot serialize item is not attached");
    }
    const ops = [];
    const op = {
      id: this._id,
      opId: pool == null ? void 0 : pool.generateOpId(),
      type: 2 /* CREATE_LIST */,
      parentId,
      parentKey
    };
    ops.push(op);
    for (const item of this._items) {
      ops.push(...item._toOps(this._id, item._getParentKeyOrThrow(), pool));
    }
    return ops;
  }
  /**
   * @internal
   *
   * Adds a new item into the sorted list, in the correct position.
   */
  _insertAndSort(item) {
    this._items.push(item);
    this._sortItems();
  }
  /** @internal */
  _sortItems() {
    this._items.sort(compareNodePosition);
    this.invalidate();
  }
  /** @internal */
  _indexOfPosition(position) {
    return this._items.findIndex(
      (item) => item._getParentKeyOrThrow() === position
    );
  }
  /** @internal */
  _attach(id, pool) {
    super._attach(id, pool);
    for (const item of this._items) {
      item._attach(pool.generateId(), pool);
    }
  }
  /** @internal */
  _detach() {
    super._detach();
    for (const item of this._items) {
      item._detach();
    }
  }
  /** @internal */
  _applySetRemote(op) {
    if (this._pool === void 0) {
      throw new Error("Can't attach child if managed pool is not present");
    }
    const { id, parentKey: key } = op;
    const child = creationOpToLiveNode(op);
    child._attach(id, this._pool);
    child._setParentLink(this, key);
    const deletedId = op.deletedId;
    const indexOfItemWithSamePosition = this._indexOfPosition(key);
    if (indexOfItemWithSamePosition !== -1) {
      const itemWithSamePosition = this._items[indexOfItemWithSamePosition];
      if (itemWithSamePosition._id === deletedId) {
        itemWithSamePosition._detach();
        this._items[indexOfItemWithSamePosition] = child;
        return {
          modified: makeUpdate(this, [
            setDelta(indexOfItemWithSamePosition, child)
          ]),
          reverse: []
        };
      } else {
        this._implicitlyDeletedItems.add(itemWithSamePosition);
        this._items[indexOfItemWithSamePosition] = child;
        const delta = [
          setDelta(indexOfItemWithSamePosition, child)
        ];
        const deleteDelta2 = this._detachItemAssociatedToSetOperation(
          op.deletedId
        );
        if (deleteDelta2) {
          delta.push(deleteDelta2);
        }
        return {
          modified: makeUpdate(this, delta),
          reverse: []
        };
      }
    } else {
      const updates = [];
      const deleteDelta2 = this._detachItemAssociatedToSetOperation(
        op.deletedId
      );
      if (deleteDelta2) {
        updates.push(deleteDelta2);
      }
      this._insertAndSort(child);
      updates.push(insertDelta(this._indexOfPosition(key), child));
      return {
        reverse: [],
        modified: makeUpdate(this, updates)
      };
    }
  }
  /** @internal */
  _applySetAck(op) {
    if (this._pool === void 0) {
      throw new Error("Can't attach child if managed pool is not present");
    }
    const delta = [];
    const deletedDelta = this._detachItemAssociatedToSetOperation(op.deletedId);
    if (deletedDelta) {
      delta.push(deletedDelta);
    }
    const unacknowledgedOpId = this._unacknowledgedSets.get(op.parentKey);
    if (unacknowledgedOpId !== void 0) {
      if (unacknowledgedOpId !== op.opId) {
        return delta.length === 0 ? { modified: false } : { modified: makeUpdate(this, delta), reverse: [] };
      } else {
        this._unacknowledgedSets.delete(op.parentKey);
      }
    }
    const indexOfItemWithSamePosition = this._indexOfPosition(op.parentKey);
    const existingItem = this._items.find((item) => item._id === op.id);
    if (existingItem !== void 0) {
      if (existingItem._parentKey === op.parentKey) {
        return {
          modified: delta.length > 0 ? makeUpdate(this, delta) : false,
          reverse: []
        };
      }
      if (indexOfItemWithSamePosition !== -1) {
        this._implicitlyDeletedItems.add(
          this._items[indexOfItemWithSamePosition]
        );
        this._items.splice(indexOfItemWithSamePosition, 1);
        delta.push(deleteDelta(indexOfItemWithSamePosition));
      }
      const previousIndex = this._items.indexOf(existingItem);
      existingItem._setParentLink(this, op.parentKey);
      this._sortItems();
      const newIndex = this._items.indexOf(existingItem);
      if (newIndex !== previousIndex) {
        delta.push(moveDelta(previousIndex, newIndex, existingItem));
      }
      return {
        modified: delta.length > 0 ? makeUpdate(this, delta) : false,
        reverse: []
      };
    } else {
      const orphan = this._pool.getNode(op.id);
      if (orphan && this._implicitlyDeletedItems.has(orphan)) {
        orphan._setParentLink(this, op.parentKey);
        this._implicitlyDeletedItems.delete(orphan);
        this._insertAndSort(orphan);
        const recreatedItemIndex = this._items.indexOf(orphan);
        return {
          modified: makeUpdate(this, [
            // If there is an item at this position, update is a set, else it's an insert
            indexOfItemWithSamePosition === -1 ? insertDelta(recreatedItemIndex, orphan) : setDelta(recreatedItemIndex, orphan),
            ...delta
          ]),
          reverse: []
        };
      } else {
        if (indexOfItemWithSamePosition !== -1) {
          this._items.splice(indexOfItemWithSamePosition, 1);
        }
        const { newItem, newIndex } = this._createAttachItemAndSort(
          op,
          op.parentKey
        );
        return {
          modified: makeUpdate(this, [
            // If there is an item at this position, update is a set, else it's an insert
            indexOfItemWithSamePosition === -1 ? insertDelta(newIndex, newItem) : setDelta(newIndex, newItem),
            ...delta
          ]),
          reverse: []
        };
      }
    }
  }
  /**
   * Returns the update delta of the deletion or null
   * @internal
   */
  _detachItemAssociatedToSetOperation(deletedId) {
    if (deletedId === void 0 || this._pool === void 0) {
      return null;
    }
    const deletedItem = this._pool.getNode(deletedId);
    if (deletedItem === void 0) {
      return null;
    }
    const result = this._detachChild(deletedItem);
    if (result.modified === false) {
      return null;
    }
    return result.modified.updates[0];
  }
  /** @internal */
  _applyRemoteInsert(op) {
    if (this._pool === void 0) {
      throw new Error("Can't attach child if managed pool is not present");
    }
    const key = asPos(op.parentKey);
    const existingItemIndex = this._indexOfPosition(key);
    if (existingItemIndex !== -1) {
      this._shiftItemPosition(existingItemIndex, key);
    }
    const { newItem, newIndex } = this._createAttachItemAndSort(op, key);
    return {
      modified: makeUpdate(this, [insertDelta(newIndex, newItem)]),
      reverse: []
    };
  }
  /** @internal */
  _applyInsertAck(op) {
    const existingItem = this._items.find((item) => item._id === op.id);
    const key = asPos(op.parentKey);
    const itemIndexAtPosition = this._indexOfPosition(key);
    if (existingItem) {
      if (existingItem._parentKey === key) {
        return {
          modified: false
        };
      } else {
        const oldPositionIndex = this._items.indexOf(existingItem);
        if (itemIndexAtPosition !== -1) {
          this._shiftItemPosition(itemIndexAtPosition, key);
        }
        existingItem._setParentLink(this, key);
        this._sortItems();
        const newIndex = this._indexOfPosition(key);
        if (newIndex === oldPositionIndex) {
          return { modified: false };
        }
        return {
          modified: makeUpdate(this, [
            moveDelta(oldPositionIndex, newIndex, existingItem)
          ]),
          reverse: []
        };
      }
    } else {
      const orphan = nn(this._pool).getNode(op.id);
      if (orphan && this._implicitlyDeletedItems.has(orphan)) {
        orphan._setParentLink(this, key);
        this._implicitlyDeletedItems.delete(orphan);
        this._insertAndSort(orphan);
        const newIndex = this._indexOfPosition(key);
        return {
          modified: makeUpdate(this, [insertDelta(newIndex, orphan)]),
          reverse: []
        };
      } else {
        if (itemIndexAtPosition !== -1) {
          this._shiftItemPosition(itemIndexAtPosition, key);
        }
        const { newItem, newIndex } = this._createAttachItemAndSort(op, key);
        return {
          modified: makeUpdate(this, [insertDelta(newIndex, newItem)]),
          reverse: []
        };
      }
    }
  }
  /** @internal */
  _applyInsertUndoRedo(op) {
    var _a, _b, _c;
    const { id, parentKey: key } = op;
    const child = creationOpToLiveNode(op);
    if (((_a = this._pool) == null ? void 0 : _a.getNode(id)) !== void 0) {
      return { modified: false };
    }
    child._attach(id, nn(this._pool));
    child._setParentLink(this, key);
    const existingItemIndex = this._indexOfPosition(key);
    let newKey = key;
    if (existingItemIndex !== -1) {
      const before2 = (_b = this._items[existingItemIndex]) == null ? void 0 : _b._parentPos;
      const after2 = (_c = this._items[existingItemIndex + 1]) == null ? void 0 : _c._parentPos;
      newKey = makePosition(before2, after2);
      child._setParentLink(this, newKey);
    }
    this._insertAndSort(child);
    const newIndex = this._indexOfPosition(newKey);
    return {
      modified: makeUpdate(this, [insertDelta(newIndex, child)]),
      reverse: [{ type: 5 /* DELETE_CRDT */, id }]
    };
  }
  /** @internal */
  _applySetUndoRedo(op) {
    var _a;
    const { id, parentKey: key } = op;
    const child = creationOpToLiveNode(op);
    if (((_a = this._pool) == null ? void 0 : _a.getNode(id)) !== void 0) {
      return { modified: false };
    }
    this._unacknowledgedSets.set(key, nn(op.opId));
    const indexOfItemWithSameKey = this._indexOfPosition(key);
    child._attach(id, nn(this._pool));
    child._setParentLink(this, key);
    const newKey = key;
    if (indexOfItemWithSameKey !== -1) {
      const existingItem = this._items[indexOfItemWithSameKey];
      existingItem._detach();
      this._items[indexOfItemWithSameKey] = child;
      const reverse = HACK_addIntentAndDeletedIdToOperation(
        existingItem._toOps(nn(this._id), key, this._pool),
        op.id
      );
      const delta = [setDelta(indexOfItemWithSameKey, child)];
      const deletedDelta = this._detachItemAssociatedToSetOperation(
        op.deletedId
      );
      if (deletedDelta) {
        delta.push(deletedDelta);
      }
      return {
        modified: makeUpdate(this, delta),
        reverse
      };
    } else {
      this._insertAndSort(child);
      this._detachItemAssociatedToSetOperation(op.deletedId);
      const newIndex = this._indexOfPosition(newKey);
      return {
        reverse: [{ type: 5 /* DELETE_CRDT */, id }],
        modified: makeUpdate(this, [insertDelta(newIndex, child)])
      };
    }
  }
  /** @internal */
  _attachChild(op, source) {
    if (this._pool === void 0) {
      throw new Error("Can't attach child if managed pool is not present");
    }
    let result;
    if (op.intent === "set") {
      if (source === 1 /* REMOTE */) {
        result = this._applySetRemote(op);
      } else if (source === 2 /* ACK */) {
        result = this._applySetAck(op);
      } else {
        result = this._applySetUndoRedo(op);
      }
    } else {
      if (source === 1 /* REMOTE */) {
        result = this._applyRemoteInsert(op);
      } else if (source === 2 /* ACK */) {
        result = this._applyInsertAck(op);
      } else {
        result = this._applyInsertUndoRedo(op);
      }
    }
    if (result.modified !== false) {
      this.invalidate();
    }
    return result;
  }
  /** @internal */
  _detachChild(child) {
    if (child) {
      const parentKey = nn(child._parentKey);
      const reverse = child._toOps(nn(this._id), parentKey, this._pool);
      const indexToDelete = this._items.indexOf(child);
      if (indexToDelete === -1) {
        return {
          modified: false
        };
      }
      this._items.splice(indexToDelete, 1);
      this.invalidate();
      child._detach();
      return {
        modified: makeUpdate(this, [deleteDelta(indexToDelete)]),
        reverse
      };
    }
    return { modified: false };
  }
  /** @internal */
  _applySetChildKeyRemote(newKey, child) {
    var _a;
    if (this._implicitlyDeletedItems.has(child)) {
      this._implicitlyDeletedItems.delete(child);
      child._setParentLink(this, newKey);
      this._insertAndSort(child);
      const newIndex = this._items.indexOf(child);
      return {
        modified: makeUpdate(this, [insertDelta(newIndex, child)]),
        reverse: []
      };
    }
    const previousKey = child._parentKey;
    if (newKey === previousKey) {
      return {
        modified: false
      };
    }
    const existingItemIndex = this._indexOfPosition(newKey);
    if (existingItemIndex === -1) {
      const previousIndex = this._items.indexOf(child);
      child._setParentLink(this, newKey);
      this._sortItems();
      const newIndex = this._items.indexOf(child);
      if (newIndex === previousIndex) {
        return {
          modified: false
        };
      }
      return {
        modified: makeUpdate(this, [moveDelta(previousIndex, newIndex, child)]),
        reverse: []
      };
    } else {
      this._items[existingItemIndex]._setParentLink(
        this,
        makePosition(newKey, (_a = this._items[existingItemIndex + 1]) == null ? void 0 : _a._parentPos)
      );
      const previousIndex = this._items.indexOf(child);
      child._setParentLink(this, newKey);
      this._sortItems();
      const newIndex = this._items.indexOf(child);
      if (newIndex === previousIndex) {
        return {
          modified: false
        };
      }
      return {
        modified: makeUpdate(this, [moveDelta(previousIndex, newIndex, child)]),
        reverse: []
      };
    }
  }
  /** @internal */
  _applySetChildKeyAck(newKey, child) {
    var _a, _b;
    const previousKey = nn(child._parentKey);
    if (this._implicitlyDeletedItems.has(child)) {
      const existingItemIndex = this._indexOfPosition(newKey);
      this._implicitlyDeletedItems.delete(child);
      if (existingItemIndex !== -1) {
        this._items[existingItemIndex]._setParentLink(
          this,
          makePosition(newKey, (_a = this._items[existingItemIndex + 1]) == null ? void 0 : _a._parentPos)
        );
      }
      child._setParentLink(this, newKey);
      this._insertAndSort(child);
      return {
        modified: false
      };
    } else {
      if (newKey === previousKey) {
        return {
          modified: false
        };
      }
      const previousIndex = this._items.indexOf(child);
      const existingItemIndex = this._indexOfPosition(newKey);
      if (existingItemIndex !== -1) {
        this._items[existingItemIndex]._setParentLink(
          this,
          makePosition(newKey, (_b = this._items[existingItemIndex + 1]) == null ? void 0 : _b._parentPos)
        );
      }
      child._setParentLink(this, newKey);
      this._sortItems();
      const newIndex = this._items.indexOf(child);
      if (previousIndex === newIndex) {
        return {
          modified: false
        };
      } else {
        return {
          modified: makeUpdate(this, [
            moveDelta(previousIndex, newIndex, child)
          ]),
          reverse: []
        };
      }
    }
  }
  /** @internal */
  _applySetChildKeyUndoRedo(newKey, child) {
    var _a;
    const previousKey = nn(child._parentKey);
    const previousIndex = this._items.indexOf(child);
    const existingItemIndex = this._indexOfPosition(newKey);
    if (existingItemIndex !== -1) {
      this._items[existingItemIndex]._setParentLink(
        this,
        makePosition(newKey, (_a = this._items[existingItemIndex + 1]) == null ? void 0 : _a._parentPos)
      );
    }
    child._setParentLink(this, newKey);
    this._sortItems();
    const newIndex = this._items.indexOf(child);
    if (previousIndex === newIndex) {
      return {
        modified: false
      };
    }
    return {
      modified: makeUpdate(this, [moveDelta(previousIndex, newIndex, child)]),
      reverse: [
        {
          type: 1 /* SET_PARENT_KEY */,
          id: nn(child._id),
          parentKey: previousKey
        }
      ]
    };
  }
  /** @internal */
  _setChildKey(newKey, child, source) {
    if (source === 1 /* REMOTE */) {
      return this._applySetChildKeyRemote(newKey, child);
    } else if (source === 2 /* ACK */) {
      return this._applySetChildKeyAck(newKey, child);
    } else {
      return this._applySetChildKeyUndoRedo(newKey, child);
    }
  }
  /** @internal */
  _apply(op, isLocal) {
    return super._apply(op, isLocal);
  }
  /** @internal */
  _serialize() {
    if (this.parent.type !== "HasParent") {
      throw new Error("Cannot serialize LiveList if parent is missing");
    }
    return {
      type: 1 /* LIST */,
      parentId: nn(this.parent.node._id, "Parent node expected to have ID"),
      parentKey: this.parent.key
    };
  }
  /**
   * Returns the number of elements.
   */
  get length() {
    return this._items.length;
  }
  /**
   * Adds one element to the end of the LiveList.
   * @param element The element to add to the end of the LiveList.
   */
  push(element) {
    var _a;
    (_a = this._pool) == null ? void 0 : _a.assertStorageIsWritable();
    return this.insert(element, this.length);
  }
  /**
   * Inserts one element at a specified index.
   * @param element The element to insert.
   * @param index The index at which you want to insert the element.
   */
  insert(element, index) {
    var _a;
    (_a = this._pool) == null ? void 0 : _a.assertStorageIsWritable();
    if (index < 0 || index > this._items.length) {
      throw new Error(
        `Cannot insert list item at index "${index}". index should be between 0 and ${this._items.length}`
      );
    }
    const before2 = this._items[index - 1] ? this._items[index - 1]._parentPos : void 0;
    const after2 = this._items[index] ? this._items[index]._parentPos : void 0;
    const position = makePosition(before2, after2);
    const value = lsonToLiveNode(element);
    value._setParentLink(this, position);
    this._insertAndSort(value);
    if (this._pool && this._id) {
      const id = this._pool.generateId();
      value._attach(id, this._pool);
      this._pool.dispatch(
        value._toOps(this._id, position, this._pool),
        [{ type: 5 /* DELETE_CRDT */, id }],
        /* @__PURE__ */ new Map([
          [this._id, makeUpdate(this, [insertDelta(index, value)])]
        ])
      );
    }
  }
  /**
   * Move one element from one index to another.
   * @param index The index of the element to move
   * @param targetIndex The index where the element should be after moving.
   */
  move(index, targetIndex) {
    var _a;
    (_a = this._pool) == null ? void 0 : _a.assertStorageIsWritable();
    if (targetIndex < 0) {
      throw new Error("targetIndex cannot be less than 0");
    }
    if (targetIndex >= this._items.length) {
      throw new Error(
        "targetIndex cannot be greater or equal than the list length"
      );
    }
    if (index < 0) {
      throw new Error("index cannot be less than 0");
    }
    if (index >= this._items.length) {
      throw new Error("index cannot be greater or equal than the list length");
    }
    let beforePosition = null;
    let afterPosition = null;
    if (index < targetIndex) {
      afterPosition = targetIndex === this._items.length - 1 ? void 0 : this._items[targetIndex + 1]._parentPos;
      beforePosition = this._items[targetIndex]._parentPos;
    } else {
      afterPosition = this._items[targetIndex]._parentPos;
      beforePosition = targetIndex === 0 ? void 0 : this._items[targetIndex - 1]._parentPos;
    }
    const position = makePosition(beforePosition, afterPosition);
    const item = this._items[index];
    const previousPosition = item._getParentKeyOrThrow();
    item._setParentLink(this, position);
    this._sortItems();
    if (this._pool && this._id) {
      const storageUpdates = /* @__PURE__ */ new Map([
        [this._id, makeUpdate(this, [moveDelta(index, targetIndex, item)])]
      ]);
      this._pool.dispatch(
        [
          {
            type: 1 /* SET_PARENT_KEY */,
            id: nn(item._id),
            opId: this._pool.generateOpId(),
            parentKey: position
          }
        ],
        [
          {
            type: 1 /* SET_PARENT_KEY */,
            id: nn(item._id),
            parentKey: previousPosition
          }
        ],
        storageUpdates
      );
    }
  }
  /**
   * Deletes an element at the specified index
   * @param index The index of the element to delete
   */
  delete(index) {
    var _a;
    (_a = this._pool) == null ? void 0 : _a.assertStorageIsWritable();
    if (index < 0 || index >= this._items.length) {
      throw new Error(
        `Cannot delete list item at index "${index}". index should be between 0 and ${this._items.length - 1}`
      );
    }
    const item = this._items[index];
    item._detach();
    this._items.splice(index, 1);
    this.invalidate();
    if (this._pool) {
      const childRecordId = item._id;
      if (childRecordId) {
        const storageUpdates = /* @__PURE__ */ new Map();
        storageUpdates.set(
          nn(this._id),
          makeUpdate(this, [deleteDelta(index)])
        );
        this._pool.dispatch(
          [
            {
              id: childRecordId,
              opId: this._pool.generateOpId(),
              type: 5 /* DELETE_CRDT */
            }
          ],
          item._toOps(nn(this._id), item._getParentKeyOrThrow()),
          storageUpdates
        );
      }
    }
  }
  clear() {
    var _a;
    (_a = this._pool) == null ? void 0 : _a.assertStorageIsWritable();
    if (this._pool) {
      const ops = [];
      const reverseOps = [];
      const updateDelta = [];
      for (const item of this._items) {
        item._detach();
        const childId = item._id;
        if (childId) {
          ops.push({
            type: 5 /* DELETE_CRDT */,
            id: childId,
            opId: this._pool.generateOpId()
          });
          reverseOps.push(
            ...item._toOps(nn(this._id), item._getParentKeyOrThrow())
          );
          updateDelta.push(deleteDelta(0));
        }
      }
      this._items = [];
      this.invalidate();
      const storageUpdates = /* @__PURE__ */ new Map();
      storageUpdates.set(nn(this._id), makeUpdate(this, updateDelta));
      this._pool.dispatch(ops, reverseOps, storageUpdates);
    } else {
      for (const item of this._items) {
        item._detach();
      }
      this._items = [];
      this.invalidate();
    }
  }
  set(index, item) {
    var _a;
    (_a = this._pool) == null ? void 0 : _a.assertStorageIsWritable();
    if (index < 0 || index >= this._items.length) {
      throw new Error(
        `Cannot set list item at index "${index}". index should be between 0 and ${this._items.length - 1}`
      );
    }
    const existingItem = this._items[index];
    const position = existingItem._getParentKeyOrThrow();
    const existingId = existingItem._id;
    existingItem._detach();
    const value = lsonToLiveNode(item);
    value._setParentLink(this, position);
    this._items[index] = value;
    this.invalidate();
    if (this._pool && this._id) {
      const id = this._pool.generateId();
      value._attach(id, this._pool);
      const storageUpdates = /* @__PURE__ */ new Map();
      storageUpdates.set(this._id, makeUpdate(this, [setDelta(index, value)]));
      const ops = HACK_addIntentAndDeletedIdToOperation(
        value._toOps(this._id, position, this._pool),
        existingId
      );
      this._unacknowledgedSets.set(position, nn(ops[0].opId));
      const reverseOps = HACK_addIntentAndDeletedIdToOperation(
        existingItem._toOps(this._id, position, void 0),
        id
      );
      this._pool.dispatch(ops, reverseOps, storageUpdates);
    }
  }
  /**
   * Returns an Array of all the elements in the LiveList.
   */
  toArray() {
    return this._items.map(
      (entry) => liveNodeToLson(entry)
      //                               ^^^^^^^^
      //                               FIXME! This isn't safe.
    );
  }
  /**
   * Tests whether all elements pass the test implemented by the provided function.
   * @param predicate Function to test for each element, taking two arguments (the element and its index).
   * @returns true if the predicate function returns a truthy value for every element. Otherwise, false.
   */
  every(predicate) {
    return this.toArray().every(predicate);
  }
  /**
   * Creates an array with all elements that pass the test implemented by the provided function.
   * @param predicate Function to test each element of the LiveList. Return a value that coerces to true to keep the element, or to false otherwise.
   * @returns An array with the elements that pass the test.
   */
  filter(predicate) {
    return this.toArray().filter(predicate);
  }
  /**
   * Returns the first element that satisfies the provided testing function.
   * @param predicate Function to execute on each value.
   * @returns The value of the first element in the LiveList that satisfies the provided testing function. Otherwise, undefined is returned.
   */
  find(predicate) {
    return this.toArray().find(predicate);
  }
  /**
   * Returns the index of the first element in the LiveList that satisfies the provided testing function.
   * @param predicate Function to execute on each value until the function returns true, indicating that the satisfying element was found.
   * @returns The index of the first element in the LiveList that passes the test. Otherwise, -1.
   */
  findIndex(predicate) {
    return this.toArray().findIndex(predicate);
  }
  /**
   * Executes a provided function once for each element.
   * @param callbackfn Function to execute on each element.
   */
  forEach(callbackfn) {
    return this.toArray().forEach(callbackfn);
  }
  /**
   * Get the element at the specified index.
   * @param index The index on the element to get.
   * @returns The element at the specified index or undefined.
   */
  get(index) {
    if (index < 0 || index >= this._items.length) {
      return void 0;
    }
    return liveNodeToLson(this._items[index]);
  }
  /**
   * Returns the first index at which a given element can be found in the LiveList, or -1 if it is not present.
   * @param searchElement Element to locate.
   * @param fromIndex The index to start the search at.
   * @returns The first index of the element in the LiveList; -1 if not found.
   */
  indexOf(searchElement, fromIndex) {
    return this.toArray().indexOf(searchElement, fromIndex);
  }
  /**
   * Returns the last index at which a given element can be found in the LiveList, or -1 if it is not present. The LiveLsit is searched backwards, starting at fromIndex.
   * @param searchElement Element to locate.
   * @param fromIndex The index at which to start searching backwards.
   * @returns
   */
  lastIndexOf(searchElement, fromIndex) {
    return this.toArray().lastIndexOf(searchElement, fromIndex);
  }
  /**
   * Creates an array populated with the results of calling a provided function on every element.
   * @param callback Function that is called for every element.
   * @returns An array with each element being the result of the callback function.
   */
  map(callback) {
    return this._items.map(
      (entry, i) => callback(
        liveNodeToLson(entry),
        //                    ^^^^^^^^
        //                    FIXME! This isn't safe.
        i
      )
    );
  }
  /**
   * Tests whether at least one element in the LiveList passes the test implemented by the provided function.
   * @param predicate Function to test for each element.
   * @returns true if the callback function returns a truthy value for at least one element. Otherwise, false.
   */
  some(predicate) {
    return this.toArray().some(predicate);
  }
  [Symbol.iterator]() {
    return new LiveListIterator(this._items);
  }
  /** @internal */
  _createAttachItemAndSort(op, key) {
    const newItem = creationOpToLiveNode(op);
    newItem._attach(op.id, nn(this._pool));
    newItem._setParentLink(this, key);
    this._insertAndSort(newItem);
    const newIndex = this._indexOfPosition(key);
    return { newItem, newIndex };
  }
  /** @internal */
  _shiftItemPosition(index, key) {
    var _a;
    const shiftedPosition = makePosition(
      key,
      this._items.length > index + 1 ? (_a = this._items[index + 1]) == null ? void 0 : _a._parentPos : void 0
    );
    this._items[index]._setParentLink(this, shiftedPosition);
  }
  /** @internal */
  _toTreeNode(key) {
    var _a;
    return {
      type: "LiveList",
      id: (_a = this._id) != null ? _a : nanoid(),
      key,
      payload: this._items.map(
        (item, index) => item.toTreeNode(index.toString())
      )
    };
  }
  toImmutable() {
    return super.toImmutable();
  }
  /** @internal */
  _toImmutable() {
    const result = this._items.map((node) => node.toImmutable());
    return process.env.NODE_ENV === "production" ? result : Object.freeze(result);
  }
};
var LiveListIterator = class {
  constructor(items) {
    this._innerIterator = items[Symbol.iterator]();
  }
  [Symbol.iterator]() {
    return this;
  }
  next() {
    const result = this._innerIterator.next();
    if (result.done) {
      return {
        done: true,
        value: void 0
      };
    }
    const value = liveNodeToLson(result.value);
    return { value };
  }
};
function makeUpdate(liveList, deltaUpdates) {
  return {
    node: liveList,
    type: "LiveList",
    updates: deltaUpdates
  };
}
function setDelta(index, item) {
  return {
    index,
    type: "set",
    item: item instanceof LiveRegister ? item.data : item
  };
}
function deleteDelta(index) {
  return {
    index,
    type: "delete"
  };
}
function insertDelta(index, item) {
  return {
    index,
    type: "insert",
    item: item instanceof LiveRegister ? item.data : item
  };
}
function moveDelta(previousIndex, index, item) {
  return {
    index,
    type: "move",
    previousIndex,
    item: item instanceof LiveRegister ? item.data : item
  };
}
function HACK_addIntentAndDeletedIdToOperation(ops, deletedId) {
  return ops.map((op, index) => {
    if (index === 0) {
      const firstOp = op;
      return __spreadProps(__spreadValues({}, firstOp), {
        intent: "set",
        deletedId
      });
    } else {
      return op;
    }
  });
}

// src/lib/freeze.ts
var freeze = process.env.NODE_ENV === "production" ? (
  /* istanbul ignore next */
  (x) => x
) : Object.freeze;

// src/crdts/LiveMap.ts
var LiveMap = class extends AbstractCrdt {
  constructor(entries2) {
    super();
    this.unacknowledgedSet = /* @__PURE__ */ new Map();
    if (entries2) {
      const mappedEntries = [];
      for (const entry of entries2) {
        const value = lsonToLiveNode(entry[1]);
        value._setParentLink(this, entry[0]);
        mappedEntries.push([entry[0], value]);
      }
      this._map = new Map(mappedEntries);
    } else {
      this._map = /* @__PURE__ */ new Map();
    }
  }
  /**
   * @internal
   */
  _toOps(parentId, parentKey, pool) {
    if (this._id === void 0) {
      throw new Error("Cannot serialize item is not attached");
    }
    const ops = [];
    const op = {
      id: this._id,
      opId: pool == null ? void 0 : pool.generateOpId(),
      type: 7 /* CREATE_MAP */,
      parentId,
      parentKey
    };
    ops.push(op);
    for (const [key, value] of this._map) {
      ops.push(...value._toOps(this._id, key, pool));
    }
    return ops;
  }
  /**
   * @internal
   */
  static _deserialize([id, _item], parentToChildren, pool) {
    const map = new LiveMap();
    map._attach(id, pool);
    const children = parentToChildren.get(id);
    if (children === void 0) {
      return map;
    }
    for (const [id2, crdt] of children) {
      const child = deserialize([id2, crdt], parentToChildren, pool);
      child._setParentLink(map, crdt.parentKey);
      map._map.set(crdt.parentKey, child);
      map.invalidate();
    }
    return map;
  }
  /**
   * @internal
   */
  _attach(id, pool) {
    super._attach(id, pool);
    for (const [_key, value] of this._map) {
      if (isLiveNode(value)) {
        value._attach(pool.generateId(), pool);
      }
    }
  }
  /**
   * @internal
   */
  _attachChild(op, source) {
    if (this._pool === void 0) {
      throw new Error("Can't attach child if managed pool is not present");
    }
    const { id, parentKey, opId } = op;
    const key = parentKey;
    const child = creationOpToLiveNode(op);
    if (this._pool.getNode(id) !== void 0) {
      return { modified: false };
    }
    if (source === 2 /* ACK */) {
      const lastUpdateOpId = this.unacknowledgedSet.get(key);
      if (lastUpdateOpId === opId) {
        this.unacknowledgedSet.delete(key);
        return { modified: false };
      } else if (lastUpdateOpId !== void 0) {
        return { modified: false };
      }
    } else if (source === 1 /* REMOTE */) {
      this.unacknowledgedSet.delete(key);
    }
    const previousValue = this._map.get(key);
    let reverse;
    if (previousValue) {
      const thisId = nn(this._id);
      reverse = previousValue._toOps(thisId, key);
      previousValue._detach();
    } else {
      reverse = [{ type: 5 /* DELETE_CRDT */, id }];
    }
    child._setParentLink(this, key);
    child._attach(id, this._pool);
    this._map.set(key, child);
    this.invalidate();
    return {
      modified: {
        node: this,
        type: "LiveMap",
        updates: { [key]: { type: "update" } }
      },
      reverse
    };
  }
  /**
   * @internal
   */
  _detach() {
    super._detach();
    for (const item of this._map.values()) {
      item._detach();
    }
  }
  /**
   * @internal
   */
  _detachChild(child) {
    const id = nn(this._id);
    const parentKey = nn(child._parentKey);
    const reverse = child._toOps(id, parentKey, this._pool);
    for (const [key, value] of this._map) {
      if (value === child) {
        this._map.delete(key);
        this.invalidate();
      }
    }
    child._detach();
    const storageUpdate = {
      node: this,
      type: "LiveMap",
      updates: { [parentKey]: { type: "delete" } }
    };
    return { modified: storageUpdate, reverse };
  }
  /**
   * @internal
   */
  _serialize() {
    if (this.parent.type !== "HasParent") {
      throw new Error("Cannot serialize LiveMap if parent is missing");
    }
    return {
      type: 2 /* MAP */,
      parentId: nn(this.parent.node._id, "Parent node expected to have ID"),
      parentKey: this.parent.key
    };
  }
  /**
   * Returns a specified element from the LiveMap.
   * @param key The key of the element to return.
   * @returns The element associated with the specified key, or undefined if the key can't be found in the LiveMap.
   */
  get(key) {
    const value = this._map.get(key);
    if (value === void 0) {
      return void 0;
    }
    return liveNodeToLson(value);
  }
  /**
   * Adds or updates an element with a specified key and a value.
   * @param key The key of the element to add. Should be a string.
   * @param value The value of the element to add. Should be serializable to JSON.
   */
  set(key, value) {
    var _a;
    (_a = this._pool) == null ? void 0 : _a.assertStorageIsWritable();
    const oldValue = this._map.get(key);
    if (oldValue) {
      oldValue._detach();
    }
    const item = lsonToLiveNode(value);
    item._setParentLink(this, key);
    this._map.set(key, item);
    this.invalidate();
    if (this._pool && this._id) {
      const id = this._pool.generateId();
      item._attach(id, this._pool);
      const storageUpdates = /* @__PURE__ */ new Map();
      storageUpdates.set(this._id, {
        node: this,
        type: "LiveMap",
        updates: { [key]: { type: "update" } }
      });
      const ops = item._toOps(this._id, key, this._pool);
      this.unacknowledgedSet.set(key, nn(ops[0].opId));
      this._pool.dispatch(
        item._toOps(this._id, key, this._pool),
        oldValue ? oldValue._toOps(this._id, key) : [{ type: 5 /* DELETE_CRDT */, id }],
        storageUpdates
      );
    }
  }
  /**
   * Returns the number of elements in the LiveMap.
   */
  get size() {
    return this._map.size;
  }
  /**
   * Returns a boolean indicating whether an element with the specified key exists or not.
   * @param key The key of the element to test for presence.
   */
  has(key) {
    return this._map.has(key);
  }
  /**
   * Removes the specified element by key.
   * @param key The key of the element to remove.
   * @returns true if an element existed and has been removed, or false if the element does not exist.
   */
  delete(key) {
    var _a;
    (_a = this._pool) == null ? void 0 : _a.assertStorageIsWritable();
    const item = this._map.get(key);
    if (item === void 0) {
      return false;
    }
    item._detach();
    this._map.delete(key);
    this.invalidate();
    if (this._pool && item._id) {
      const thisId = nn(this._id);
      const storageUpdates = /* @__PURE__ */ new Map();
      storageUpdates.set(thisId, {
        node: this,
        type: "LiveMap",
        updates: { [key]: { type: "delete" } }
      });
      this._pool.dispatch(
        [
          {
            type: 5 /* DELETE_CRDT */,
            id: item._id,
            opId: this._pool.generateOpId()
          }
        ],
        item._toOps(thisId, key),
        storageUpdates
      );
    }
    return true;
  }
  /**
   * Returns a new Iterator object that contains the [key, value] pairs for each element.
   */
  entries() {
    const innerIterator = this._map.entries();
    return {
      [Symbol.iterator]() {
        return this;
      },
      next() {
        const iteratorValue = innerIterator.next();
        if (iteratorValue.done) {
          return {
            done: true,
            value: void 0
          };
        }
        const entry = iteratorValue.value;
        const key = entry[0];
        const value = liveNodeToLson(iteratorValue.value[1]);
        return {
          value: [key, value]
        };
      }
    };
  }
  /**
   * Same function object as the initial value of the entries method.
   */
  [Symbol.iterator]() {
    return this.entries();
  }
  /**
   * Returns a new Iterator object that contains the keys for each element.
   */
  keys() {
    return this._map.keys();
  }
  /**
   * Returns a new Iterator object that contains the values for each element.
   */
  values() {
    const innerIterator = this._map.values();
    return {
      [Symbol.iterator]() {
        return this;
      },
      next() {
        const iteratorValue = innerIterator.next();
        if (iteratorValue.done) {
          return {
            done: true,
            value: void 0
          };
        }
        const value = liveNodeToLson(iteratorValue.value);
        return { value };
      }
    };
  }
  /**
   * Executes a provided function once per each key/value pair in the Map object, in insertion order.
   * @param callback Function to execute for each entry in the map.
   */
  forEach(callback) {
    for (const entry of this) {
      callback(entry[1], entry[0], this);
    }
  }
  /** @internal */
  _toTreeNode(key) {
    var _a;
    return {
      type: "LiveMap",
      id: (_a = this._id) != null ? _a : nanoid(),
      key,
      payload: Array.from(this._map.entries()).map(
        ([key2, val]) => val.toTreeNode(key2)
      )
    };
  }
  toImmutable() {
    return super.toImmutable();
  }
  /** @internal */
  _toImmutable() {
    const result = /* @__PURE__ */ new Map();
    for (const [key, value] of this._map) {
      result.set(key, value.toImmutable());
    }
    return freeze(result);
  }
};

// src/crdts/LiveObject.ts
var LiveObject = class extends AbstractCrdt {
  constructor(obj = {}) {
    super();
    this._propToLastUpdate = /* @__PURE__ */ new Map();
    for (const key in obj) {
      const value = obj[key];
      if (value === void 0) {
        continue;
      } else if (isLiveNode(value)) {
        value._setParentLink(this, key);
      }
    }
    this._map = new Map(Object.entries(obj));
  }
  /** @internal */
  static _buildRootAndParentToChildren(items) {
    const parentToChildren = /* @__PURE__ */ new Map();
    let root = null;
    for (const [id, crdt] of items) {
      if (isRootCrdt(crdt)) {
        root = [id, crdt];
      } else {
        const tuple = [id, crdt];
        const children = parentToChildren.get(crdt.parentId);
        if (children !== void 0) {
          children.push(tuple);
        } else {
          parentToChildren.set(crdt.parentId, [tuple]);
        }
      }
    }
    if (root === null) {
      throw new Error("Root can't be null");
    }
    return [root, parentToChildren];
  }
  /** @internal */
  static _fromItems(items, pool) {
    const [root, parentToChildren] = LiveObject._buildRootAndParentToChildren(items);
    return LiveObject._deserialize(
      root,
      parentToChildren,
      pool
    );
  }
  /** @internal */
  _toOps(parentId, parentKey, pool) {
    if (this._id === void 0) {
      throw new Error("Cannot serialize item is not attached");
    }
    const opId = pool == null ? void 0 : pool.generateOpId();
    const ops = [];
    const op = parentId !== void 0 && parentKey !== void 0 ? {
      type: 4 /* CREATE_OBJECT */,
      id: this._id,
      opId,
      parentId,
      parentKey,
      data: {}
    } : (
      // Root object
      { type: 4 /* CREATE_OBJECT */, id: this._id, opId, data: {} }
    );
    ops.push(op);
    for (const [key, value] of this._map) {
      if (isLiveNode(value)) {
        ops.push(...value._toOps(this._id, key, pool));
      } else {
        op.data[key] = value;
      }
    }
    return ops;
  }
  /** @internal */
  static _deserialize([id, item], parentToChildren, pool) {
    const liveObj = new LiveObject(item.data);
    liveObj._attach(id, pool);
    return this._deserializeChildren(liveObj, parentToChildren, pool);
  }
  /** @internal */
  static _deserializeChildren(liveObj, parentToChildren, pool) {
    const children = parentToChildren.get(nn(liveObj._id));
    if (children === void 0) {
      return liveObj;
    }
    for (const [id, crdt] of children) {
      const child = deserializeToLson([id, crdt], parentToChildren, pool);
      if (isLiveStructure(child)) {
        child._setParentLink(liveObj, crdt.parentKey);
      }
      liveObj._map.set(crdt.parentKey, child);
      liveObj.invalidate();
    }
    return liveObj;
  }
  /** @internal */
  _attach(id, pool) {
    super._attach(id, pool);
    for (const [_key, value] of this._map) {
      if (isLiveNode(value)) {
        value._attach(pool.generateId(), pool);
      }
    }
  }
  /** @internal */
  _attachChild(op, source) {
    if (this._pool === void 0) {
      throw new Error("Can't attach child if managed pool is not present");
    }
    const { id, opId, parentKey: key } = op;
    const child = creationOpToLson(op);
    if (this._pool.getNode(id) !== void 0) {
      if (this._propToLastUpdate.get(key) === opId) {
        this._propToLastUpdate.delete(key);
      }
      return { modified: false };
    }
    if (source === 0 /* UNDOREDO_RECONNECT */) {
      this._propToLastUpdate.set(key, nn(opId));
    } else if (this._propToLastUpdate.get(key) === void 0) {
    } else if (this._propToLastUpdate.get(key) === opId) {
      this._propToLastUpdate.delete(key);
      return { modified: false };
    } else {
      return { modified: false };
    }
    const thisId = nn(this._id);
    const previousValue = this._map.get(key);
    let reverse;
    if (isLiveNode(previousValue)) {
      reverse = previousValue._toOps(thisId, key);
      previousValue._detach();
    } else if (previousValue === void 0) {
      reverse = [{ type: 6 /* DELETE_OBJECT_KEY */, id: thisId, key }];
    } else {
      reverse = [
        {
          type: 3 /* UPDATE_OBJECT */,
          id: thisId,
          data: { [key]: previousValue }
        }
      ];
    }
    this._map.set(key, child);
    this.invalidate();
    if (isLiveStructure(child)) {
      child._setParentLink(this, key);
      child._attach(id, this._pool);
    }
    return {
      reverse,
      modified: {
        node: this,
        type: "LiveObject",
        updates: { [key]: { type: "update" } }
      }
    };
  }
  /** @internal */
  _detachChild(child) {
    if (child) {
      const id = nn(this._id);
      const parentKey = nn(child._parentKey);
      const reverse = child._toOps(id, parentKey, this._pool);
      for (const [key, value] of this._map) {
        if (value === child) {
          this._map.delete(key);
          this.invalidate();
        }
      }
      child._detach();
      const storageUpdate = {
        node: this,
        type: "LiveObject",
        updates: {
          [parentKey]: { type: "delete" }
        }
      };
      return { modified: storageUpdate, reverse };
    }
    return { modified: false };
  }
  /**
   * @internal
   */
  _detach() {
    super._detach();
    for (const value of this._map.values()) {
      if (isLiveNode(value)) {
        value._detach();
      }
    }
  }
  /** @internal */
  _apply(op, isLocal) {
    if (op.type === 3 /* UPDATE_OBJECT */) {
      return this._applyUpdate(op, isLocal);
    } else if (op.type === 6 /* DELETE_OBJECT_KEY */) {
      return this._applyDeleteObjectKey(op, isLocal);
    }
    return super._apply(op, isLocal);
  }
  /**
   * @internal
   */
  _serialize() {
    const data = {};
    for (const [key, value] of this._map) {
      if (!isLiveNode(value)) {
        data[key] = value;
      }
    }
    if (this.parent.type === "HasParent" && this.parent.node._id) {
      return {
        type: 0 /* OBJECT */,
        parentId: this.parent.node._id,
        parentKey: this.parent.key,
        data
      };
    } else {
      return {
        type: 0 /* OBJECT */,
        data
      };
    }
  }
  /** @internal */
  _applyUpdate(op, isLocal) {
    let isModified = false;
    const id = nn(this._id);
    const reverse = [];
    const reverseUpdate = {
      type: 3 /* UPDATE_OBJECT */,
      id,
      data: {}
    };
    reverse.push(reverseUpdate);
    for (const key in op.data) {
      const oldValue = this._map.get(key);
      if (isLiveNode(oldValue)) {
        reverse.push(...oldValue._toOps(id, key));
        oldValue._detach();
      } else if (oldValue !== void 0) {
        reverseUpdate.data[key] = oldValue;
      } else if (oldValue === void 0) {
        reverse.push({ type: 6 /* DELETE_OBJECT_KEY */, id, key });
      }
    }
    const updateDelta = {};
    for (const key in op.data) {
      const value = op.data[key];
      if (value === void 0) {
        continue;
      }
      if (isLocal) {
        this._propToLastUpdate.set(key, nn(op.opId));
      } else if (this._propToLastUpdate.get(key) === void 0) {
        isModified = true;
      } else if (this._propToLastUpdate.get(key) === op.opId) {
        this._propToLastUpdate.delete(key);
        continue;
      } else {
        continue;
      }
      const oldValue = this._map.get(key);
      if (isLiveNode(oldValue)) {
        oldValue._detach();
      }
      isModified = true;
      updateDelta[key] = { type: "update" };
      this._map.set(key, value);
      this.invalidate();
    }
    if (Object.keys(reverseUpdate.data).length !== 0) {
      reverse.unshift(reverseUpdate);
    }
    return isModified ? {
      modified: {
        node: this,
        type: "LiveObject",
        updates: updateDelta
      },
      reverse
    } : { modified: false };
  }
  /** @internal */
  _applyDeleteObjectKey(op, isLocal) {
    const key = op.key;
    if (this._map.has(key) === false) {
      return { modified: false };
    }
    if (!isLocal && this._propToLastUpdate.get(key) !== void 0) {
      return { modified: false };
    }
    const oldValue = this._map.get(key);
    const id = nn(this._id);
    let reverse = [];
    if (isLiveNode(oldValue)) {
      reverse = oldValue._toOps(id, op.key);
      oldValue._detach();
    } else if (oldValue !== void 0) {
      reverse = [
        {
          type: 3 /* UPDATE_OBJECT */,
          id,
          data: { [key]: oldValue }
        }
      ];
    }
    this._map.delete(key);
    this.invalidate();
    return {
      modified: {
        node: this,
        type: "LiveObject",
        updates: { [op.key]: { type: "delete" } }
      },
      reverse
    };
  }
  /**
   * Transform the LiveObject into a javascript object
   */
  toObject() {
    return fromEntries(this._map);
  }
  /**
   * Adds or updates a property with a specified key and a value.
   * @param key The key of the property to add
   * @param value The value of the property to add
   */
  set(key, value) {
    var _a;
    (_a = this._pool) == null ? void 0 : _a.assertStorageIsWritable();
    this.update({ [key]: value });
  }
  /**
   * Returns a specified property from the LiveObject.
   * @param key The key of the property to get
   */
  get(key) {
    return this._map.get(key);
  }
  /**
   * Deletes a key from the LiveObject
   * @param key The key of the property to delete
   */
  delete(key) {
    var _a;
    (_a = this._pool) == null ? void 0 : _a.assertStorageIsWritable();
    const keyAsString = key;
    const oldValue = this._map.get(keyAsString);
    if (oldValue === void 0) {
      return;
    }
    if (this._pool === void 0 || this._id === void 0) {
      if (isLiveNode(oldValue)) {
        oldValue._detach();
      }
      this._map.delete(keyAsString);
      this.invalidate();
      return;
    }
    let reverse;
    if (isLiveNode(oldValue)) {
      oldValue._detach();
      reverse = oldValue._toOps(this._id, keyAsString);
    } else {
      reverse = [
        {
          type: 3 /* UPDATE_OBJECT */,
          data: { [keyAsString]: oldValue },
          id: this._id
        }
      ];
    }
    this._map.delete(keyAsString);
    this.invalidate();
    const storageUpdates = /* @__PURE__ */ new Map();
    storageUpdates.set(this._id, {
      node: this,
      type: "LiveObject",
      updates: { [key]: { type: "delete" } }
    });
    this._pool.dispatch(
      [
        {
          type: 6 /* DELETE_OBJECT_KEY */,
          key: keyAsString,
          id: this._id,
          opId: this._pool.generateOpId()
        }
      ],
      reverse,
      storageUpdates
    );
  }
  /**
   * Adds or updates multiple properties at once with an object.
   * @param patch The object used to overrides properties
   */
  update(patch) {
    var _a;
    (_a = this._pool) == null ? void 0 : _a.assertStorageIsWritable();
    if (this._pool === void 0 || this._id === void 0) {
      for (const key in patch) {
        const newValue = patch[key];
        if (newValue === void 0) {
          continue;
        }
        const oldValue = this._map.get(key);
        if (isLiveNode(oldValue)) {
          oldValue._detach();
        }
        if (isLiveNode(newValue)) {
          newValue._setParentLink(this, key);
        }
        this._map.set(key, newValue);
        this.invalidate();
      }
      return;
    }
    const ops = [];
    const reverseOps = [];
    const opId = this._pool.generateOpId();
    const updatedProps = {};
    const reverseUpdateOp = {
      id: this._id,
      type: 3 /* UPDATE_OBJECT */,
      data: {}
    };
    const updateDelta = {};
    for (const key in patch) {
      const newValue = patch[key];
      if (newValue === void 0) {
        continue;
      }
      const oldValue = this._map.get(key);
      if (isLiveNode(oldValue)) {
        reverseOps.push(...oldValue._toOps(this._id, key));
        oldValue._detach();
      } else if (oldValue === void 0) {
        reverseOps.push({ type: 6 /* DELETE_OBJECT_KEY */, id: this._id, key });
      } else {
        reverseUpdateOp.data[key] = oldValue;
      }
      if (isLiveNode(newValue)) {
        newValue._setParentLink(this, key);
        newValue._attach(this._pool.generateId(), this._pool);
        const newAttachChildOps = newValue._toOps(this._id, key, this._pool);
        const createCrdtOp = newAttachChildOps.find(
          (op) => op.parentId === this._id
        );
        if (createCrdtOp) {
          this._propToLastUpdate.set(key, nn(createCrdtOp.opId));
        }
        ops.push(...newAttachChildOps);
      } else {
        updatedProps[key] = newValue;
        this._propToLastUpdate.set(key, opId);
      }
      this._map.set(key, newValue);
      this.invalidate();
      updateDelta[key] = { type: "update" };
    }
    if (Object.keys(reverseUpdateOp.data).length !== 0) {
      reverseOps.unshift(reverseUpdateOp);
    }
    if (Object.keys(updatedProps).length !== 0) {
      ops.unshift({
        opId,
        id: this._id,
        type: 3 /* UPDATE_OBJECT */,
        data: updatedProps
      });
    }
    const storageUpdates = /* @__PURE__ */ new Map();
    storageUpdates.set(this._id, {
      node: this,
      type: "LiveObject",
      updates: updateDelta
    });
    this._pool.dispatch(ops, reverseOps, storageUpdates);
  }
  toImmutable() {
    return super.toImmutable();
  }
  /** @internal */
  toTreeNode(key) {
    return super.toTreeNode(key);
  }
  /** @internal */
  _toTreeNode(key) {
    var _a;
    const nodeId = (_a = this._id) != null ? _a : nanoid();
    return {
      type: "LiveObject",
      id: nodeId,
      key,
      payload: Array.from(this._map.entries()).map(
        ([key2, value]) => isLiveNode(value) ? value.toTreeNode(key2) : { type: "Json", id: `${nodeId}:${key2}`, key: key2, payload: value }
      )
    };
  }
  /** @internal */
  _toImmutable() {
    const result = {};
    for (const [key, val] of this._map) {
      result[key] = isLiveStructure(val) ? val.toImmutable() : val;
    }
    return process.env.NODE_ENV === "production" ? result : Object.freeze(result);
  }
};

// src/crdts/liveblocks-helpers.ts
function creationOpToLiveNode(op) {
  return lsonToLiveNode(creationOpToLson(op));
}
function creationOpToLson(op) {
  switch (op.type) {
    case 8 /* CREATE_REGISTER */:
      return op.data;
    case 4 /* CREATE_OBJECT */:
      return new LiveObject(op.data);
    case 7 /* CREATE_MAP */:
      return new LiveMap();
    case 2 /* CREATE_LIST */:
      return new LiveList();
    default:
      return assertNever(op, "Unknown creation Op");
  }
}
function isSameNodeOrChildOf(node, parent) {
  if (node === parent) {
    return true;
  }
  if (node.parent.type === "HasParent") {
    return isSameNodeOrChildOf(node.parent.node, parent);
  }
  return false;
}
function deserialize([id, crdt], parentToChildren, pool) {
  switch (crdt.type) {
    case 0 /* OBJECT */: {
      return LiveObject._deserialize([id, crdt], parentToChildren, pool);
    }
    case 1 /* LIST */: {
      return LiveList._deserialize([id, crdt], parentToChildren, pool);
    }
    case 2 /* MAP */: {
      return LiveMap._deserialize([id, crdt], parentToChildren, pool);
    }
    case 3 /* REGISTER */: {
      return LiveRegister._deserialize([id, crdt], parentToChildren, pool);
    }
    default: {
      throw new Error("Unexpected CRDT type");
    }
  }
}
function deserializeToLson([id, crdt], parentToChildren, pool) {
  switch (crdt.type) {
    case 0 /* OBJECT */: {
      return LiveObject._deserialize([id, crdt], parentToChildren, pool);
    }
    case 1 /* LIST */: {
      return LiveList._deserialize([id, crdt], parentToChildren, pool);
    }
    case 2 /* MAP */: {
      return LiveMap._deserialize([id, crdt], parentToChildren, pool);
    }
    case 3 /* REGISTER */: {
      return crdt.data;
    }
    default: {
      throw new Error("Unexpected CRDT type");
    }
  }
}
function isLiveStructure(value) {
  return isLiveList(value) || isLiveMap(value) || isLiveObject(value);
}
function isLiveNode(value) {
  return isLiveStructure(value) || isLiveRegister(value);
}
function isLiveList(value) {
  return value instanceof LiveList;
}
function isLiveMap(value) {
  return value instanceof LiveMap;
}
function isLiveObject(value) {
  return value instanceof LiveObject;
}
function isLiveRegister(value) {
  return value instanceof LiveRegister;
}
function liveNodeToLson(obj) {
  if (obj instanceof LiveRegister) {
    return obj.data;
  } else if (obj instanceof LiveList || obj instanceof LiveMap || obj instanceof LiveObject) {
    return obj;
  } else {
    return assertNever(obj, "Unknown AbstractCrdt");
  }
}
function lsonToLiveNode(value) {
  if (value instanceof LiveObject || value instanceof LiveMap || value instanceof LiveList) {
    return value;
  } else {
    return new LiveRegister(value);
  }
}
function getTreesDiffOperations(currentItems, newItems) {
  const ops = [];
  currentItems.forEach((_, id) => {
    if (!newItems.get(id)) {
      ops.push({
        type: 5 /* DELETE_CRDT */,
        id
      });
    }
  });
  newItems.forEach((crdt, id) => {
    const currentCrdt = currentItems.get(id);
    if (currentCrdt) {
      if (crdt.type === 0 /* OBJECT */) {
        if (currentCrdt.type !== 0 /* OBJECT */ || JSON.stringify(crdt.data) !== JSON.stringify(currentCrdt.data)) {
          ops.push({
            type: 3 /* UPDATE_OBJECT */,
            id,
            data: crdt.data
          });
        }
      }
      if (crdt.parentKey !== currentCrdt.parentKey) {
        ops.push({
          type: 1 /* SET_PARENT_KEY */,
          id,
          parentKey: nn(crdt.parentKey, "Parent key must not be missing")
        });
      }
    } else {
      switch (crdt.type) {
        case 3 /* REGISTER */:
          ops.push({
            type: 8 /* CREATE_REGISTER */,
            id,
            parentId: crdt.parentId,
            parentKey: crdt.parentKey,
            data: crdt.data
          });
          break;
        case 1 /* LIST */:
          ops.push({
            type: 2 /* CREATE_LIST */,
            id,
            parentId: crdt.parentId,
            parentKey: crdt.parentKey
          });
          break;
        case 0 /* OBJECT */:
          ops.push(
            crdt.parentId ? {
              type: 4 /* CREATE_OBJECT */,
              id,
              parentId: crdt.parentId,
              parentKey: crdt.parentKey,
              data: crdt.data
            } : (
              // Root object
              { type: 4 /* CREATE_OBJECT */, id, data: crdt.data }
            )
          );
          break;
        case 2 /* MAP */:
          ops.push({
            type: 7 /* CREATE_MAP */,
            id,
            parentId: crdt.parentId,
            parentKey: crdt.parentKey
          });
          break;
      }
    }
  });
  return ops;
}
function mergeObjectStorageUpdates(first, second) {
  const updates = first.updates;
  for (const [key, value] of entries(second.updates)) {
    updates[key] = value;
  }
  return __spreadProps(__spreadValues({}, second), {
    updates
  });
}
function mergeMapStorageUpdates(first, second) {
  const updates = first.updates;
  for (const [key, value] of entries(second.updates)) {
    updates[key] = value;
  }
  return __spreadProps(__spreadValues({}, second), {
    updates
  });
}
function mergeListStorageUpdates(first, second) {
  const updates = first.updates;
  return __spreadProps(__spreadValues({}, second), {
    updates: updates.concat(second.updates)
  });
}
function mergeStorageUpdates(first, second) {
  if (first === void 0) {
    return second;
  }
  if (first.type === "LiveObject" && second.type === "LiveObject") {
    return mergeObjectStorageUpdates(first, second);
  } else if (first.type === "LiveMap" && second.type === "LiveMap") {
    return mergeMapStorageUpdates(first, second);
  } else if (first.type === "LiveList" && second.type === "LiveList") {
    return mergeListStorageUpdates(first, second);
  } else {
  }
  return second;
}
function isPlain(value) {
  const type = typeof value;
  return value === void 0 || value === null || type === "string" || type === "boolean" || type === "number" || Array.isArray(value) || isPlainObject(value);
}
function findNonSerializableValue(value, path = "") {
  if (!isPlain) {
    return {
      path: path || "root",
      value
    };
  }
  if (typeof value !== "object" || value === null) {
    return false;
  }
  for (const [key, nestedValue] of Object.entries(value)) {
    const nestedPath = path ? path + "." + key : key;
    if (!isPlain(nestedValue)) {
      return {
        path: nestedPath,
        value: nestedValue
      };
    }
    if (typeof nestedValue === "object") {
      const nonSerializableNestedValue = findNonSerializableValue(
        nestedValue,
        nestedPath
      );
      if (nonSerializableNestedValue) {
        return nonSerializableNestedValue;
      }
    }
  }
  return false;
}

// src/lib/debug.ts
function captureStackTrace(msg, traceRoot) {
  const errorLike = { name: msg };
  if (typeof Error.captureStackTrace !== "function") {
    return void 0;
  }
  Error.captureStackTrace(errorLike, traceRoot);
  return errorLike.stack;
}

// src/lib/Json.ts
function isJsonScalar(data) {
  return data === null || typeof data === "string" || typeof data === "number" || typeof data === "boolean";
}
function isJsonArray(data) {
  return Array.isArray(data);
}
function isJsonObject(data) {
  return !isJsonScalar(data) && !isJsonArray(data);
}

// src/protocol/AuthToken.ts
function hasJwtMeta(data) {
  if (!isPlainObject(data)) {
    return false;
  }
  const { iat, exp } = data;
  return typeof iat === "number" && typeof exp === "number";
}
function isTokenExpired(token) {
  const now = Date.now() / 1e3;
  return now > token.exp - 300 || now < token.iat + 300;
}
function isStringList(value) {
  return Array.isArray(value) && value.every((i) => typeof i === "string");
}
function isAppOnlyAuthToken(data) {
  return typeof data.appId === "string" && data.roomId === void 0 && isStringList(data.scopes);
}
function isRoomAuthToken(data) {
  return typeof data.appId === "string" && typeof data.roomId === "string" && typeof data.actor === "number" && (data.id === void 0 || typeof data.id === "string") && isStringList(data.scopes) && (data.maxConnectionsPerRoom === void 0 || typeof data.maxConnectionsPerRoom === "number");
}
function isAuthToken(data) {
  return isAppOnlyAuthToken(data) || isRoomAuthToken(data);
}
function parseJwtToken(token) {
  const tokenParts = token.split(".");
  if (tokenParts.length !== 3) {
    throw new Error("Authentication error: invalid JWT token");
  }
  const data = tryParseJson(b64decode(tokenParts[1]));
  if (data && hasJwtMeta(data)) {
    return data;
  } else {
    throw new Error("Authentication error: missing JWT metadata");
  }
}
function parseRoomAuthToken(tokenString) {
  const data = parseJwtToken(tokenString);
  if (data && isRoomAuthToken(data)) {
    const _a = data, {
      maxConnections: _legacyField
    } = _a, token = __objRest(_a, [
      // If this legacy field is found on the token, pretend it wasn't there,
      // to make all internally used token payloads uniform
      "maxConnections"
    ]);
    return token;
  } else {
    throw new Error(
      "Authentication error: we expected a room token but did not get one. Hint: if you are using a callback, ensure the room is passed when creating the token. For more information: https://liveblocks.io/docs/api-reference/liveblocks-client#createClientCallback"
    );
  }
}

// src/protocol/ClientMsg.ts
var ClientMsgCode = /* @__PURE__ */ ((ClientMsgCode2) => {
  ClientMsgCode2[ClientMsgCode2["UPDATE_PRESENCE"] = 100] = "UPDATE_PRESENCE";
  ClientMsgCode2[ClientMsgCode2["BROADCAST_EVENT"] = 103] = "BROADCAST_EVENT";
  ClientMsgCode2[ClientMsgCode2["FETCH_STORAGE"] = 200] = "FETCH_STORAGE";
  ClientMsgCode2[ClientMsgCode2["UPDATE_STORAGE"] = 201] = "UPDATE_STORAGE";
  return ClientMsgCode2;
})(ClientMsgCode || {});

// src/protocol/ServerMsg.ts
var ServerMsgCode = /* @__PURE__ */ ((ServerMsgCode2) => {
  ServerMsgCode2[ServerMsgCode2["UPDATE_PRESENCE"] = 100] = "UPDATE_PRESENCE";
  ServerMsgCode2[ServerMsgCode2["USER_JOINED"] = 101] = "USER_JOINED";
  ServerMsgCode2[ServerMsgCode2["USER_LEFT"] = 102] = "USER_LEFT";
  ServerMsgCode2[ServerMsgCode2["BROADCASTED_EVENT"] = 103] = "BROADCASTED_EVENT";
  ServerMsgCode2[ServerMsgCode2["ROOM_STATE"] = 104] = "ROOM_STATE";
  ServerMsgCode2[ServerMsgCode2["INITIAL_STORAGE_STATE"] = 200] = "INITIAL_STORAGE_STATE";
  ServerMsgCode2[ServerMsgCode2["UPDATE_STORAGE"] = 201] = "UPDATE_STORAGE";
  ServerMsgCode2[ServerMsgCode2["REJECT_STORAGE_OP"] = 299] = "REJECT_STORAGE_OP";
  return ServerMsgCode2;
})(ServerMsgCode || {});

// src/refs/ImmutableRef.ts
function merge(target, patch) {
  let updated = false;
  const newValue = __spreadValues({}, target);
  Object.keys(patch).forEach((k) => {
    const key = k;
    const val = patch[key];
    if (newValue[key] !== val) {
      if (val === void 0) {
        delete newValue[key];
      } else {
        newValue[key] = val;
      }
      updated = true;
    }
  });
  return updated ? newValue : target;
}
var ImmutableRef = class {
  constructor() {
    this._ev = makeEventSource();
  }
  get didInvalidate() {
    return this._ev.observable;
  }
  invalidate() {
    if (this._cache !== void 0) {
      this._cache = void 0;
      this._ev.notify();
    }
  }
  get current() {
    var _a;
    return (_a = this._cache) != null ? _a : this._cache = this._toImmutable();
  }
};

// src/refs/MeRef.ts
var MeRef = class extends ImmutableRef {
  constructor(initialPresence) {
    super();
    this._me = freeze(compactObject(initialPresence));
  }
  /** @internal */
  _toImmutable() {
    return this._me;
  }
  /**
   * Patches the current "me" instance.
   */
  patch(patch) {
    const oldMe = this._me;
    const newMe = merge(oldMe, patch);
    if (oldMe !== newMe) {
      this._me = freeze(newMe);
      this.invalidate();
    }
  }
};

// src/lib/LegacyArray.ts
function asArrayWithLegacyMethods(arr) {
  Object.defineProperty(arr, "count", {
    value: arr.length,
    enumerable: false
  });
  Object.defineProperty(arr, "toArray", {
    value: () => arr,
    enumerable: false
  });
  return freeze(arr);
}

// src/refs/OthersRef.ts
function makeUser(conn, presence) {
  return freeze(compactObject(__spreadProps(__spreadValues({}, conn), { presence })));
}
var OthersRef = class extends ImmutableRef {
  //
  // --------------------------------------------------------------
  //
  constructor() {
    super();
    this._connections = {};
    this._presences = {};
    this._users = {};
  }
  /** @internal */
  _toImmutable() {
    const users = compact(
      Object.keys(this._presences).map(
        (connectionId) => this.getUser(Number(connectionId))
      )
    );
    return asArrayWithLegacyMethods(users);
  }
  clearOthers() {
    this._connections = {};
    this._presences = {};
    this._users = {};
    this.invalidate();
  }
  /** @internal */
  _getUser(connectionId) {
    const conn = this._connections[connectionId];
    const presence = this._presences[connectionId];
    if (conn !== void 0 && presence !== void 0) {
      return makeUser(conn, presence);
    }
    return void 0;
  }
  getUser(connectionId) {
    const cachedUser = this._users[connectionId];
    if (cachedUser) {
      return cachedUser;
    }
    const computedUser = this._getUser(connectionId);
    if (computedUser) {
      this._users[connectionId] = computedUser;
      return computedUser;
    }
    return void 0;
  }
  /** @internal */
  _invalidateUser(connectionId) {
    if (this._users[connectionId] !== void 0) {
      delete this._users[connectionId];
    }
    this.invalidate();
  }
  /**
   * Records a known connection. This records the connection ID and the
   * associated metadata.
   */
  setConnection(connectionId, metaUserId, metaUserInfo, metaIsReadonly) {
    this._connections[connectionId] = freeze({
      connectionId,
      id: metaUserId,
      info: metaUserInfo,
      isReadOnly: metaIsReadonly
    });
    if (this._presences[connectionId] !== void 0) {
      this._invalidateUser(connectionId);
    }
  }
  /**
   * Removes a known connectionId. Removes both the connection's metadata and
   * the presence information.
   */
  removeConnection(connectionId) {
    delete this._connections[connectionId];
    delete this._presences[connectionId];
    this._invalidateUser(connectionId);
  }
  /**
   * Stores a new user from a full presence update. If the user already exists,
   * its known presence data is overwritten.
   */
  setOther(connectionId, presence) {
    this._presences[connectionId] = freeze(compactObject(presence));
    if (this._connections[connectionId] !== void 0) {
      this._invalidateUser(connectionId);
    }
  }
  /**
   * Patches the presence data for an existing "other". If we don't know the
   * initial presence data for this user yet, discard this patch and await the
   * full .setOther() call first.
   */
  patchOther(connectionId, patch) {
    const oldPresence = this._presences[connectionId];
    if (oldPresence === void 0) {
      return;
    }
    const newPresence = merge(oldPresence, patch);
    if (oldPresence !== newPresence) {
      this._presences[connectionId] = freeze(newPresence);
      this._invalidateUser(connectionId);
    }
  }
};

// src/refs/ValueRef.ts
var ValueRef = class extends ImmutableRef {
  constructor(initialValue) {
    super();
    this._value = freeze(initialValue);
  }
  /** @internal */
  _toImmutable() {
    return this._value;
  }
  set(newValue) {
    this._value = freeze(newValue);
    this.invalidate();
  }
};
var DerivedRef = class extends ImmutableRef {
  constructor(...args) {
    super();
    const transformFn = args.pop();
    const otherRefs = args;
    this._refs = otherRefs;
    this._refs.forEach((ref) => {
      ref.didInvalidate.subscribe(() => this.invalidate());
    });
    this._transform = transformFn;
  }
  /** @internal */
  _toImmutable() {
    return this._transform(
      ...this._refs.map((ref) => ref.current)
    );
  }
};

// src/types/IWebSocket.ts
var WebsocketCloseCodes = /* @__PURE__ */ ((WebsocketCloseCodes2) => {
  WebsocketCloseCodes2[WebsocketCloseCodes2["CLOSE_ABNORMAL"] = 1006] = "CLOSE_ABNORMAL";
  WebsocketCloseCodes2[WebsocketCloseCodes2["INVALID_MESSAGE_FORMAT"] = 4e3] = "INVALID_MESSAGE_FORMAT";
  WebsocketCloseCodes2[WebsocketCloseCodes2["NOT_ALLOWED"] = 4001] = "NOT_ALLOWED";
  WebsocketCloseCodes2[WebsocketCloseCodes2["MAX_NUMBER_OF_MESSAGES_PER_SECONDS"] = 4002] = "MAX_NUMBER_OF_MESSAGES_PER_SECONDS";
  WebsocketCloseCodes2[WebsocketCloseCodes2["MAX_NUMBER_OF_CONCURRENT_CONNECTIONS"] = 4003] = "MAX_NUMBER_OF_CONCURRENT_CONNECTIONS";
  WebsocketCloseCodes2[WebsocketCloseCodes2["MAX_NUMBER_OF_MESSAGES_PER_DAY_PER_APP"] = 4004] = "MAX_NUMBER_OF_MESSAGES_PER_DAY_PER_APP";
  WebsocketCloseCodes2[WebsocketCloseCodes2["MAX_NUMBER_OF_CONCURRENT_CONNECTIONS_PER_ROOM"] = 4005] = "MAX_NUMBER_OF_CONCURRENT_CONNECTIONS_PER_ROOM";
  WebsocketCloseCodes2[WebsocketCloseCodes2["CLOSE_WITHOUT_RETRY"] = 4999] = "CLOSE_WITHOUT_RETRY";
  return WebsocketCloseCodes2;
})(WebsocketCloseCodes || {});

// src/room.ts
var BACKOFF_RETRY_DELAYS = [250, 500, 1e3, 2e3, 4e3, 8e3, 1e4];
var BACKOFF_RETRY_DELAYS_SLOW = [2e3, 3e4, 6e4, 3e5];
var HEARTBEAT_INTERVAL = 3e4;
var PONG_TIMEOUT = 2e3;
function makeIdFactory(connectionId) {
  let count = 0;
  return () => `${connectionId}:${count++}`;
}
function log(..._params) {
  return;
}
function isConnectionSelfAware(connection) {
  return connection.status === "open" || connection.status === "connecting";
}
function userToTreeNode(key, user) {
  return {
    type: "User",
    id: `${user.connectionId}`,
    key,
    payload: user
  };
}
function createRoom(options, config) {
  var _a;
  const initialPresence = typeof options.initialPresence === "function" ? options.initialPresence(config.roomId) : options.initialPresence;
  const initialStorage = typeof options.initialStorage === "function" ? options.initialStorage(config.roomId) : options.initialStorage;
  const context = {
    token: null,
    lastConnectionId: null,
    socket: null,
    numRetries: 0,
    timers: {
      flush: void 0,
      reconnect: void 0,
      heartbeat: void 0,
      pongTimeout: void 0
    },
    buffer: {
      lastFlushedAt: 0,
      me: (
        // Queue up the initial presence message as a Full Presence™ update
        {
          type: "full",
          data: initialPresence
        }
      ),
      messages: [],
      storageOperations: []
    },
    connection: new ValueRef({ status: "closed" }),
    me: new MeRef(initialPresence),
    others: new OthersRef(),
    initialStorage,
    idFactory: null,
    // Storage
    clock: 0,
    opClock: 0,
    nodes: /* @__PURE__ */ new Map(),
    root: void 0,
    undoStack: [],
    redoStack: [],
    pausedHistory: null,
    activeBatch: null,
    unacknowledgedOps: /* @__PURE__ */ new Map(),
    // Debug
    opStackTraces: process.env.NODE_ENV !== "production" ? /* @__PURE__ */ new Map() : void 0
  };
  const doNotBatchUpdates = (cb) => cb();
  const batchUpdates = (_a = config.unstable_batchedUpdates) != null ? _a : doNotBatchUpdates;
  const pool = {
    roomId: config.roomId,
    getNode: (id) => context.nodes.get(id),
    addNode: (id, node) => void context.nodes.set(id, node),
    deleteNode: (id) => void context.nodes.delete(id),
    generateId: () => `${getConnectionId()}:${context.clock++}`,
    generateOpId: () => `${getConnectionId()}:${context.opClock++}`,
    dispatch(ops, reverse, storageUpdates) {
      const activeBatch = context.activeBatch;
      if (process.env.NODE_ENV !== "production") {
        const stackTrace = captureStackTrace("Storage mutation", this.dispatch);
        if (stackTrace) {
          for (const op of ops) {
            if (op.opId) {
              nn(context.opStackTraces).set(op.opId, stackTrace);
            }
          }
        }
      }
      if (activeBatch) {
        activeBatch.ops.push(...ops);
        for (const [key, value] of storageUpdates) {
          activeBatch.updates.storageUpdates.set(
            key,
            mergeStorageUpdates(
              activeBatch.updates.storageUpdates.get(key),
              value
            )
          );
        }
        activeBatch.reverseOps.unshift(...reverse);
      } else {
        batchUpdates(() => {
          addToUndoStack(reverse, doNotBatchUpdates);
          context.redoStack = [];
          dispatchOps(ops);
          notify({ storageUpdates }, doNotBatchUpdates);
        });
      }
    },
    assertStorageIsWritable: () => {
      if (isConnectionSelfAware(context.connection.current) && context.connection.current.isReadOnly) {
        throw new Error(
          "Cannot write to storage with a read only user, please ensure the user has write permissions"
        );
      }
    }
  };
  const eventHub = {
    customEvent: makeEventSource(),
    me: makeEventSource(),
    others: makeEventSource(),
    error: makeEventSource(),
    connection: makeEventSource(),
    storage: makeEventSource(),
    history: makeEventSource(),
    storageDidLoad: makeEventSource(),
    storageStatus: makeEventSource()
  };
  const effects = config.mockedEffects || {
    authenticate(auth, createWebSocket) {
      const prevToken = context.token;
      if (prevToken !== null && !isTokenExpired(prevToken.parsed)) {
        const socket = createWebSocket(prevToken.raw);
        authenticationSuccess(prevToken.parsed, socket);
        return void 0;
      } else {
        void auth(config.roomId).then(({ token }) => {
          if (context.connection.current.status !== "authenticating") {
            return;
          }
          const parsedToken = parseRoomAuthToken(token);
          const socket = createWebSocket(token);
          authenticationSuccess(parsedToken, socket);
          context.token = { raw: token, parsed: parsedToken };
        }).catch(
          (er) => authenticationFailure(
            er instanceof Error ? er : new Error(String(er))
          )
        );
        return void 0;
      }
    },
    send(messageOrMessages) {
      if (context.socket === null) {
        throw new Error("Can't send message if socket is null");
      }
      if (context.socket.readyState === context.socket.OPEN) {
        context.socket.send(JSON.stringify(messageOrMessages));
      }
    },
    scheduleFlush: (delay) => setTimeout(tryFlushing, delay),
    scheduleReconnect: (delay) => setTimeout(connect, delay),
    startHeartbeatInterval: () => setInterval(heartbeat, HEARTBEAT_INTERVAL),
    schedulePongTimeout: () => setTimeout(pongTimeout, PONG_TIMEOUT)
  };
  const self = new DerivedRef(
    context.connection,
    context.me,
    (conn, me) => isConnectionSelfAware(conn) ? {
      connectionId: conn.id,
      id: conn.userId,
      info: conn.userInfo,
      presence: me,
      isReadOnly: conn.isReadOnly
    } : null
  );
  const selfAsTreeNode = new DerivedRef(
    self,
    (me) => me !== null ? userToTreeNode("Me", me) : null
  );
  function createOrUpdateRootFromMessage(message, batchedUpdatesWrapper) {
    if (message.items.length === 0) {
      throw new Error("Internal error: cannot load storage without items");
    }
    if (context.root) {
      updateRoot(message.items, batchedUpdatesWrapper);
    } else {
      context.root = LiveObject._fromItems(message.items, pool);
    }
    for (const key in context.initialStorage) {
      if (context.root.get(key) === void 0) {
        context.root.set(key, context.initialStorage[key]);
      }
    }
  }
  function updateRoot(items, batchedUpdatesWrapper) {
    if (!context.root) {
      return;
    }
    const currentItems = /* @__PURE__ */ new Map();
    for (const [id, node] of context.nodes) {
      currentItems.set(id, node._serialize());
    }
    const ops = getTreesDiffOperations(currentItems, new Map(items));
    const result = applyOps(ops, false);
    notify(result.updates, batchedUpdatesWrapper);
  }
  function _addToRealUndoStack(historyOps, batchedUpdatesWrapper) {
    if (context.undoStack.length >= 50) {
      context.undoStack.shift();
    }
    context.undoStack.push(historyOps);
    onHistoryChange(batchedUpdatesWrapper);
  }
  function addToUndoStack(historyOps, batchedUpdatesWrapper) {
    if (context.pausedHistory !== null) {
      context.pausedHistory.unshift(...historyOps);
    } else {
      _addToRealUndoStack(historyOps, batchedUpdatesWrapper);
    }
  }
  function notify({
    storageUpdates = /* @__PURE__ */ new Map(),
    presence = false,
    others: otherEvents = []
  }, batchedUpdatesWrapper) {
    batchedUpdatesWrapper(() => {
      if (otherEvents.length > 0) {
        const others = context.others.current;
        for (const event of otherEvents) {
          eventHub.others.notify({ others, event });
        }
      }
      if (presence) {
        eventHub.me.notify(context.me.current);
      }
      if (storageUpdates.size > 0) {
        const updates = Array.from(storageUpdates.values());
        eventHub.storage.notify(updates);
      }
    });
  }
  function getConnectionId() {
    const conn = context.connection.current;
    if (isConnectionSelfAware(conn)) {
      return conn.id;
    } else if (context.lastConnectionId !== null) {
      return context.lastConnectionId;
    }
    throw new Error(
      "Internal. Tried to get connection id but connection was never open"
    );
  }
  function applyOps(rawOps, isLocal) {
    const output = {
      reverse: [],
      storageUpdates: /* @__PURE__ */ new Map(),
      presence: false
    };
    const createdNodeIds = /* @__PURE__ */ new Set();
    const ops = rawOps.map((op) => {
      if (op.type !== "presence" && !op.opId) {
        return __spreadProps(__spreadValues({}, op), { opId: pool.generateOpId() });
      } else {
        return op;
      }
    });
    for (const op of ops) {
      if (op.type === "presence") {
        const reverse = {
          type: "presence",
          data: {}
        };
        for (const key in op.data) {
          reverse.data[key] = context.me.current[key];
        }
        context.me.patch(op.data);
        if (context.buffer.me === null) {
          context.buffer.me = { type: "partial", data: op.data };
        } else {
          for (const key in op.data) {
            context.buffer.me.data[key] = op.data[key];
          }
        }
        output.reverse.unshift(reverse);
        output.presence = true;
      } else {
        let source;
        if (isLocal) {
          source = 0 /* UNDOREDO_RECONNECT */;
        } else {
          const opId = nn(op.opId);
          if (process.env.NODE_ENV !== "production") {
            nn(context.opStackTraces).delete(opId);
          }
          const deleted = context.unacknowledgedOps.delete(opId);
          source = deleted ? 2 /* ACK */ : 1 /* REMOTE */;
        }
        const applyOpResult = applyOp(op, source);
        if (applyOpResult.modified) {
          const nodeId = applyOpResult.modified.node._id;
          if (!(nodeId && createdNodeIds.has(nodeId))) {
            output.storageUpdates.set(
              nn(applyOpResult.modified.node._id),
              mergeStorageUpdates(
                output.storageUpdates.get(nn(applyOpResult.modified.node._id)),
                applyOpResult.modified
              )
            );
            output.reverse.unshift(...applyOpResult.reverse);
          }
          if (op.type === 2 /* CREATE_LIST */ || op.type === 7 /* CREATE_MAP */ || op.type === 4 /* CREATE_OBJECT */) {
            createdNodeIds.add(nn(op.id));
          }
        }
      }
    }
    notifyStorageStatus();
    return {
      ops,
      reverse: output.reverse,
      updates: {
        storageUpdates: output.storageUpdates,
        presence: output.presence
      }
    };
  }
  function applyOp(op, source) {
    if (isAckOp(op)) {
      return { modified: false };
    }
    switch (op.type) {
      case 6 /* DELETE_OBJECT_KEY */:
      case 3 /* UPDATE_OBJECT */:
      case 5 /* DELETE_CRDT */: {
        const node = context.nodes.get(op.id);
        if (node === void 0) {
          return { modified: false };
        }
        return node._apply(op, source === 0 /* UNDOREDO_RECONNECT */);
      }
      case 1 /* SET_PARENT_KEY */: {
        const node = context.nodes.get(op.id);
        if (node === void 0) {
          return { modified: false };
        }
        if (node.parent.type === "HasParent" && isLiveList(node.parent.node)) {
          return node.parent.node._setChildKey(
            asPos(op.parentKey),
            node,
            source
          );
        }
        return { modified: false };
      }
      case 4 /* CREATE_OBJECT */:
      case 2 /* CREATE_LIST */:
      case 7 /* CREATE_MAP */:
      case 8 /* CREATE_REGISTER */: {
        if (op.parentId === void 0) {
          return { modified: false };
        }
        const parentNode = context.nodes.get(op.parentId);
        if (parentNode === void 0) {
          return { modified: false };
        }
        return parentNode._attachChild(op, source);
      }
    }
  }
  function connect() {
    var _a2, _b;
    if (context.connection.current.status !== "closed" && context.connection.current.status !== "unavailable") {
      return;
    }
    const auth = prepareAuthEndpoint(
      config.authentication,
      (_a2 = config.polyfills) == null ? void 0 : _a2.fetch
    );
    const createWebSocket = prepareCreateWebSocket(
      config.liveblocksServer,
      (_b = config.polyfills) == null ? void 0 : _b.WebSocket
    );
    updateConnection({ status: "authenticating" }, batchUpdates);
    effects.authenticate(auth, createWebSocket);
  }
  function updatePresence(patch, options2) {
    const oldValues = {};
    if (context.buffer.me === null) {
      context.buffer.me = {
        type: "partial",
        data: {}
      };
    }
    for (const key in patch) {
      const overrideValue = patch[key];
      if (overrideValue === void 0) {
        continue;
      }
      context.buffer.me.data[key] = overrideValue;
      oldValues[key] = context.me.current[key];
    }
    context.me.patch(patch);
    if (context.activeBatch) {
      if (options2 == null ? void 0 : options2.addToHistory) {
        context.activeBatch.reverseOps.unshift({
          type: "presence",
          data: oldValues
        });
      }
      context.activeBatch.updates.presence = true;
    } else {
      tryFlushing();
      batchUpdates(() => {
        if (options2 == null ? void 0 : options2.addToHistory) {
          addToUndoStack(
            [{ type: "presence", data: oldValues }],
            doNotBatchUpdates
          );
        }
        notify({ presence: true }, doNotBatchUpdates);
      });
    }
  }
  function isStorageReadOnly(scopes) {
    return scopes.includes("room:read" /* Read */) && scopes.includes("room:presence:write" /* PresenceWrite */) && !scopes.includes("room:write" /* Write */);
  }
  function authenticationSuccess(token, socket) {
    socket.addEventListener("message", onMessage);
    socket.addEventListener("open", onOpen);
    socket.addEventListener("close", onClose);
    socket.addEventListener("error", onError);
    updateConnection(
      {
        status: "connecting",
        id: token.actor,
        userInfo: token.info,
        userId: token.id,
        isReadOnly: isStorageReadOnly(token.scopes)
      },
      batchUpdates
    );
    context.idFactory = makeIdFactory(token.actor);
    context.socket = socket;
  }
  function authenticationFailure(error2) {
    if (process.env.NODE_ENV !== "production") {
      error("Call to authentication endpoint failed", error2);
    }
    context.token = null;
    updateConnection({ status: "unavailable" }, batchUpdates);
    context.numRetries++;
    clearTimeout(context.timers.reconnect);
    context.timers.reconnect = effects.scheduleReconnect(getRetryDelay());
  }
  function onVisibilityChange(visibilityState) {
    if (visibilityState === "visible" && context.connection.current.status === "open") {
      log("Heartbeat after visibility change");
      heartbeat();
    }
  }
  function onUpdatePresenceMessage(message) {
    if (message.targetActor !== void 0) {
      const oldUser = context.others.getUser(message.actor);
      context.others.setOther(message.actor, message.data);
      const newUser = context.others.getUser(message.actor);
      if (oldUser === void 0 && newUser !== void 0) {
        return { type: "enter", user: newUser };
      }
    } else {
      context.others.patchOther(message.actor, message.data), message;
    }
    const user = context.others.getUser(message.actor);
    if (user) {
      return {
        type: "update",
        updates: message.data,
        user
      };
    } else {
      return void 0;
    }
  }
  function onUserLeftMessage(message) {
    const user = context.others.getUser(message.actor);
    if (user) {
      context.others.removeConnection(message.actor);
      return { type: "leave", user };
    }
    return null;
  }
  function onRoomStateMessage(message) {
    for (const connectionId in context.others._connections) {
      const user = message.users[connectionId];
      if (user === void 0) {
        context.others.removeConnection(Number(connectionId));
      }
    }
    for (const key in message.users) {
      const user = message.users[key];
      const connectionId = Number(key);
      context.others.setConnection(
        connectionId,
        user.id,
        user.info,
        isStorageReadOnly(user.scopes)
      );
    }
    return { type: "reset" };
  }
  function onNavigatorOnline() {
    if (context.connection.current.status === "unavailable") {
      log("Try to reconnect after connectivity change");
      reconnect();
    }
  }
  function canUndo() {
    return context.undoStack.length > 0;
  }
  function canRedo() {
    return context.redoStack.length > 0;
  }
  function onHistoryChange(batchedUpdatesWrapper) {
    batchedUpdatesWrapper(() => {
      eventHub.history.notify({ canUndo: canUndo(), canRedo: canRedo() });
    });
  }
  function onUserJoinedMessage(message) {
    context.others.setConnection(
      message.actor,
      message.id,
      message.info,
      isStorageReadOnly(message.scopes)
    );
    context.buffer.messages.push({
      type: 100 /* UPDATE_PRESENCE */,
      data: context.me.current,
      targetActor: message.actor
    });
    tryFlushing();
    const user = context.others.getUser(message.actor);
    return user ? { type: "enter", user } : void 0;
  }
  function parseServerMessage(data) {
    if (!isJsonObject(data)) {
      return null;
    }
    return data;
  }
  function parseServerMessages(text) {
    const data = tryParseJson(text);
    if (data === void 0) {
      return null;
    } else if (isJsonArray(data)) {
      return compact(data.map((item) => parseServerMessage(item)));
    } else {
      return compact([parseServerMessage(data)]);
    }
  }
  function applyAndSendOps(offlineOps, batchedUpdatesWrapper) {
    if (offlineOps.size === 0) {
      return;
    }
    const messages = [];
    const ops = Array.from(offlineOps.values());
    const result = applyOps(ops, true);
    messages.push({
      type: 201 /* UPDATE_STORAGE */,
      ops: result.ops
    });
    notify(result.updates, batchedUpdatesWrapper);
    effects.send(messages);
  }
  function onMessage(event) {
    if (event.data === "pong") {
      clearTimeout(context.timers.pongTimeout);
      return;
    }
    if (typeof event.data !== "string") {
      return;
    }
    const messages = parseServerMessages(event.data);
    if (messages === null || messages.length === 0) {
      return;
    }
    const updates = {
      storageUpdates: /* @__PURE__ */ new Map(),
      others: []
    };
    batchUpdates(() => {
      var _a2;
      for (const message of messages) {
        switch (message.type) {
          case 101 /* USER_JOINED */: {
            const userJoinedUpdate = onUserJoinedMessage(message);
            if (userJoinedUpdate) {
              updates.others.push(userJoinedUpdate);
            }
            break;
          }
          case 100 /* UPDATE_PRESENCE */: {
            const othersPresenceUpdate = onUpdatePresenceMessage(message);
            if (othersPresenceUpdate) {
              updates.others.push(othersPresenceUpdate);
            }
            break;
          }
          case 103 /* BROADCASTED_EVENT */: {
            eventHub.customEvent.notify({
              connectionId: message.actor,
              event: message.event
            });
            break;
          }
          case 102 /* USER_LEFT */: {
            const event2 = onUserLeftMessage(message);
            if (event2) {
              updates.others.push(event2);
            }
            break;
          }
          case 104 /* ROOM_STATE */: {
            updates.others.push(onRoomStateMessage(message));
            break;
          }
          case 200 /* INITIAL_STORAGE_STATE */: {
            const unacknowledgedOps = new Map(context.unacknowledgedOps);
            createOrUpdateRootFromMessage(message, doNotBatchUpdates);
            applyAndSendOps(unacknowledgedOps, doNotBatchUpdates);
            if (_getInitialStateResolver !== null) {
              _getInitialStateResolver();
            }
            notifyStorageStatus();
            eventHub.storageDidLoad.notify();
            break;
          }
          case 201 /* UPDATE_STORAGE */: {
            const applyResult = applyOps(message.ops, false);
            for (const [key, value] of applyResult.updates.storageUpdates) {
              updates.storageUpdates.set(
                key,
                mergeStorageUpdates(updates.storageUpdates.get(key), value)
              );
            }
            break;
          }
          case 299 /* REJECT_STORAGE_OP */: {
            errorWithTitle(
              "Storage mutation rejection error",
              message.reason
            );
            if (process.env.NODE_ENV !== "production") {
              const traces = /* @__PURE__ */ new Set();
              for (const opId of message.opIds) {
                const trace = (_a2 = context.opStackTraces) == null ? void 0 : _a2.get(opId);
                if (trace) {
                  traces.add(trace);
                }
              }
              if (traces.size > 0) {
                warnWithTitle(
                  "The following function calls caused the rejected storage mutations:",
                  `

${Array.from(traces).join("\n\n")}`
                );
              }
              throw new Error(
                `Storage mutations rejected by server: ${message.reason}`
              );
            }
            break;
          }
        }
      }
      notify(updates, doNotBatchUpdates);
    });
  }
  function onClose(event) {
    context.socket = null;
    clearTimeout(context.timers.flush);
    clearTimeout(context.timers.reconnect);
    clearInterval(context.timers.heartbeat);
    clearTimeout(context.timers.pongTimeout);
    context.others.clearOthers();
    batchUpdates(() => {
      notify({ others: [{ type: "reset" }] }, doNotBatchUpdates);
      if (event.code >= 4e3 && event.code <= 4100) {
        updateConnection({ status: "failed" }, doNotBatchUpdates);
        const error2 = new LiveblocksError(event.reason, event.code);
        eventHub.error.notify(error2);
        const delay = getRetryDelay(true);
        context.numRetries++;
        if (process.env.NODE_ENV !== "production") {
          error(
            `Connection to websocket server closed. Reason: ${error2.message} (code: ${error2.code}). Retrying in ${delay}ms.`
          );
        }
        updateConnection({ status: "unavailable" }, doNotBatchUpdates);
        clearTimeout(context.timers.reconnect);
        context.timers.reconnect = effects.scheduleReconnect(delay);
      } else if (event.code === 4999 /* CLOSE_WITHOUT_RETRY */) {
        updateConnection({ status: "closed" }, doNotBatchUpdates);
      } else {
        const delay = getRetryDelay();
        context.numRetries++;
        if (process.env.NODE_ENV !== "production") {
          warn(
            `Connection to Liveblocks websocket server closed (code: ${event.code}). Retrying in ${delay}ms.`
          );
        }
        updateConnection({ status: "unavailable" }, doNotBatchUpdates);
        clearTimeout(context.timers.reconnect);
        context.timers.reconnect = effects.scheduleReconnect(delay);
      }
    });
  }
  function updateConnection(connection, batchedUpdatesWrapper) {
    context.connection.set(connection);
    batchedUpdatesWrapper(() => {
      eventHub.connection.notify(connection.status);
    });
  }
  function getRetryDelay(slow = false) {
    if (slow) {
      return BACKOFF_RETRY_DELAYS_SLOW[context.numRetries < BACKOFF_RETRY_DELAYS_SLOW.length ? context.numRetries : BACKOFF_RETRY_DELAYS_SLOW.length - 1];
    }
    return BACKOFF_RETRY_DELAYS[context.numRetries < BACKOFF_RETRY_DELAYS.length ? context.numRetries : BACKOFF_RETRY_DELAYS.length - 1];
  }
  function onError() {
  }
  function onOpen() {
    clearInterval(context.timers.heartbeat);
    context.timers.heartbeat = effects.startHeartbeatInterval();
    if (context.connection.current.status === "connecting") {
      updateConnection(
        __spreadProps(__spreadValues({}, context.connection.current), { status: "open" }),
        batchUpdates
      );
      context.numRetries = 0;
      if (context.lastConnectionId !== void 0) {
        context.buffer.me = {
          type: "full",
          data: (
            // Because state.me.current is a readonly object, we'll have to
            // make a copy here. Otherwise, type errors happen later when
            // "patching" my presence.
            __spreadValues({}, context.me.current)
          )
        };
        tryFlushing();
      }
      context.lastConnectionId = context.connection.current.id;
      if (context.root) {
        context.buffer.messages.push({ type: 200 /* FETCH_STORAGE */ });
      }
      tryFlushing();
    } else {
    }
  }
  function heartbeat() {
    if (context.socket === null) {
      return;
    }
    clearTimeout(context.timers.pongTimeout);
    context.timers.pongTimeout = effects.schedulePongTimeout();
    if (context.socket.readyState === context.socket.OPEN) {
      context.socket.send("ping");
    }
  }
  function pongTimeout() {
    log("Pong timeout. Trying to reconnect.");
    reconnect();
  }
  function disconnect() {
    if (context.socket) {
      context.socket.removeEventListener("open", onOpen);
      context.socket.removeEventListener("message", onMessage);
      context.socket.removeEventListener("close", onClose);
      context.socket.removeEventListener("error", onError);
      context.socket.close();
      context.socket = null;
    }
    clearTimeout(context.timers.flush);
    clearTimeout(context.timers.reconnect);
    clearInterval(context.timers.heartbeat);
    clearTimeout(context.timers.pongTimeout);
    batchUpdates(() => {
      updateConnection({ status: "closed" }, doNotBatchUpdates);
      context.others.clearOthers();
      notify({ others: [{ type: "reset" }] }, doNotBatchUpdates);
    });
    for (const eventSource2 of Object.values(eventHub)) {
      eventSource2.clear();
    }
  }
  function reconnect() {
    if (context.socket) {
      context.socket.removeEventListener("open", onOpen);
      context.socket.removeEventListener("message", onMessage);
      context.socket.removeEventListener("close", onClose);
      context.socket.removeEventListener("error", onError);
      context.socket.close();
      context.socket = null;
    }
    clearTimeout(context.timers.flush);
    clearTimeout(context.timers.reconnect);
    clearInterval(context.timers.heartbeat);
    clearTimeout(context.timers.pongTimeout);
    updateConnection({ status: "unavailable" }, batchUpdates);
    connect();
  }
  function tryFlushing() {
    const storageOps = context.buffer.storageOperations;
    if (storageOps.length > 0) {
      for (const op of storageOps) {
        context.unacknowledgedOps.set(nn(op.opId), op);
      }
      notifyStorageStatus();
    }
    if (context.socket === null || context.socket.readyState !== context.socket.OPEN) {
      context.buffer.storageOperations = [];
      return;
    }
    const now = Date.now();
    const elapsedMillis = now - context.buffer.lastFlushedAt;
    if (elapsedMillis > config.throttleDelay) {
      const messagesToFlush = serializeBuffer();
      if (messagesToFlush.length === 0) {
        return;
      }
      effects.send(messagesToFlush);
      context.buffer = {
        lastFlushedAt: now,
        messages: [],
        storageOperations: [],
        me: null
      };
    } else {
      clearTimeout(context.timers.flush);
      context.timers.flush = effects.scheduleFlush(
        config.throttleDelay - elapsedMillis
      );
    }
  }
  function serializeBuffer() {
    const messages = [];
    if (context.buffer.me) {
      messages.push(
        context.buffer.me.type === "full" ? {
          type: 100 /* UPDATE_PRESENCE */,
          // Populating the `targetActor` field turns this message into
          // a Full Presence™ update message (not a patch), which will get
          // interpreted by other clients as such.
          targetActor: -1,
          data: context.buffer.me.data
        } : {
          type: 100 /* UPDATE_PRESENCE */,
          data: context.buffer.me.data
        }
      );
    }
    for (const event of context.buffer.messages) {
      messages.push(event);
    }
    if (context.buffer.storageOperations.length > 0) {
      messages.push({
        type: 201 /* UPDATE_STORAGE */,
        ops: context.buffer.storageOperations
      });
    }
    return messages;
  }
  function broadcastEvent(event, options2 = {
    shouldQueueEventIfNotReady: false
  }) {
    if (context.socket === null && !options2.shouldQueueEventIfNotReady) {
      return;
    }
    context.buffer.messages.push({
      type: 103 /* BROADCAST_EVENT */,
      event
    });
    tryFlushing();
  }
  function dispatchOps(ops) {
    context.buffer.storageOperations.push(...ops);
    tryFlushing();
  }
  let _getInitialStatePromise = null;
  let _getInitialStateResolver = null;
  function startLoadingStorage() {
    if (_getInitialStatePromise === null) {
      context.buffer.messages.push({ type: 200 /* FETCH_STORAGE */ });
      tryFlushing();
      _getInitialStatePromise = new Promise(
        (resolve) => _getInitialStateResolver = resolve
      );
      notifyStorageStatus();
    }
    return _getInitialStatePromise;
  }
  function getStorageSnapshot() {
    const root = context.root;
    if (root !== void 0) {
      return root;
    } else {
      void startLoadingStorage();
      return null;
    }
  }
  function getStorage() {
    return __async(this, null, function* () {
      if (context.root) {
        return Promise.resolve({
          root: context.root
        });
      }
      yield startLoadingStorage();
      return {
        root: nn(context.root)
      };
    });
  }
  function undo() {
    if (context.activeBatch) {
      throw new Error("undo is not allowed during a batch");
    }
    const historyOps = context.undoStack.pop();
    if (historyOps === void 0) {
      return;
    }
    context.pausedHistory = null;
    const result = applyOps(historyOps, true);
    batchUpdates(() => {
      notify(result.updates, doNotBatchUpdates);
      context.redoStack.push(result.reverse);
      onHistoryChange(doNotBatchUpdates);
    });
    for (const op of result.ops) {
      if (op.type !== "presence") {
        context.buffer.storageOperations.push(op);
      }
    }
    tryFlushing();
  }
  function redo() {
    if (context.activeBatch) {
      throw new Error("redo is not allowed during a batch");
    }
    const historyOps = context.redoStack.pop();
    if (historyOps === void 0) {
      return;
    }
    context.pausedHistory = null;
    const result = applyOps(historyOps, true);
    batchUpdates(() => {
      notify(result.updates, doNotBatchUpdates);
      context.undoStack.push(result.reverse);
      onHistoryChange(doNotBatchUpdates);
    });
    for (const op of result.ops) {
      if (op.type !== "presence") {
        context.buffer.storageOperations.push(op);
      }
    }
    tryFlushing();
  }
  function batch(callback) {
    if (context.activeBatch) {
      return callback();
    }
    let returnValue = void 0;
    batchUpdates(() => {
      context.activeBatch = {
        ops: [],
        updates: {
          storageUpdates: /* @__PURE__ */ new Map(),
          presence: false,
          others: []
        },
        reverseOps: []
      };
      try {
        returnValue = callback();
      } finally {
        const currentBatch = context.activeBatch;
        context.activeBatch = null;
        if (currentBatch.reverseOps.length > 0) {
          addToUndoStack(currentBatch.reverseOps, doNotBatchUpdates);
        }
        if (currentBatch.ops.length > 0) {
          context.redoStack = [];
        }
        if (currentBatch.ops.length > 0) {
          dispatchOps(currentBatch.ops);
        }
        notify(currentBatch.updates, doNotBatchUpdates);
        tryFlushing();
      }
    });
    return returnValue;
  }
  function pauseHistory() {
    context.pausedHistory = [];
  }
  function resumeHistory() {
    const historyOps = context.pausedHistory;
    context.pausedHistory = null;
    if (historyOps !== null && historyOps.length > 0) {
      _addToRealUndoStack(historyOps, batchUpdates);
    }
  }
  function simulateCloseWebsocket() {
    if (context.socket) {
      context.socket = null;
    }
  }
  function simulateSendCloseEvent(event) {
    onClose(event);
  }
  function getStorageStatus() {
    if (_getInitialStatePromise === null) {
      return "not-loaded";
    }
    if (context.root === void 0) {
      return "loading";
    }
    return context.unacknowledgedOps.size === 0 ? "synchronized" : "synchronizing";
  }
  let _lastStorageStatus = getStorageStatus();
  function notifyStorageStatus() {
    const storageStatus = getStorageStatus();
    if (_lastStorageStatus !== storageStatus) {
      _lastStorageStatus = storageStatus;
      eventHub.storageStatus.notify(storageStatus);
    }
  }
  const others_forDevTools = new DerivedRef(
    context.others,
    (others) => others.map((other, index) => userToTreeNode(`Other ${index}`, other))
  );
  const events = {
    customEvent: eventHub.customEvent.observable,
    others: eventHub.others.observable,
    me: eventHub.me.observable,
    error: eventHub.error.observable,
    connection: eventHub.connection.observable,
    storage: eventHub.storage.observable,
    history: eventHub.history.observable,
    storageDidLoad: eventHub.storageDidLoad.observable,
    storageStatus: eventHub.storageStatus.observable
  };
  return {
    /* NOTE: Exposing __internal here only to allow testing implementation details in unit tests */
    __internal: {
      get buffer() {
        return context.buffer;
      },
      // prettier-ignore
      get numRetries() {
        return context.numRetries;
      },
      // prettier-ignore
      onClose,
      onMessage,
      authenticationSuccess,
      onNavigatorOnline,
      simulateCloseWebsocket,
      simulateSendCloseEvent,
      onVisibilityChange,
      getUndoStack: () => context.undoStack,
      getItemsCount: () => context.nodes.size,
      connect,
      disconnect,
      // Support for the Liveblocks browser extension
      getSelf_forDevTools: () => selfAsTreeNode.current,
      getOthers_forDevTools: () => others_forDevTools.current
    },
    id: config.roomId,
    subscribe: makeClassicSubscribeFn(events),
    reconnect,
    // Presence
    updatePresence,
    broadcastEvent,
    // Storage
    batch,
    history: {
      undo,
      redo,
      canUndo,
      canRedo,
      pause: pauseHistory,
      resume: resumeHistory
    },
    getStorage,
    getStorageSnapshot,
    getStorageStatus,
    events,
    // Core
    getConnectionState: () => context.connection.current.status,
    isSelfAware: () => isConnectionSelfAware(context.connection.current),
    getSelf: () => self.current,
    // Presence
    getPresence: () => context.me.current,
    getOthers: () => context.others.current
  };
}
function makeClassicSubscribeFn(events) {
  function subscribeToLiveStructureDeeply(node, callback) {
    return events.storage.subscribe((updates) => {
      const relatedUpdates = updates.filter(
        (update) => isSameNodeOrChildOf(update.node, node)
      );
      if (relatedUpdates.length > 0) {
        callback(relatedUpdates);
      }
    });
  }
  function subscribeToLiveStructureShallowly(node, callback) {
    return events.storage.subscribe((updates) => {
      for (const update of updates) {
        if (update.node._id === node._id) {
          callback(update.node);
        }
      }
    });
  }
  function subscribe(first, second, options) {
    if (typeof first === "string" && isRoomEventName(first)) {
      if (typeof second !== "function") {
        throw new Error("Second argument must be a callback function");
      }
      const callback = second;
      switch (first) {
        case "event":
          return events.customEvent.subscribe(
            callback
          );
        case "my-presence":
          return events.me.subscribe(callback);
        case "others": {
          const cb = callback;
          return events.others.subscribe(
            ({ others, event }) => cb(others, event)
          );
        }
        case "error":
          return events.error.subscribe(callback);
        case "connection":
          return events.connection.subscribe(
            callback
          );
        case "storage":
          return events.storage.subscribe(
            callback
          );
        case "history":
          return events.history.subscribe(callback);
        case "storage-status":
          return events.storageStatus.subscribe(
            callback
          );
        default:
          return assertNever(first, "Unknown event");
      }
    }
    if (second === void 0 || typeof first === "function") {
      if (typeof first === "function") {
        const storageCallback = first;
        return events.storage.subscribe(storageCallback);
      } else {
        throw new Error("Please specify a listener callback");
      }
    }
    if (isLiveNode(first)) {
      const node = first;
      if (options == null ? void 0 : options.isDeep) {
        const storageCallback = second;
        return subscribeToLiveStructureDeeply(node, storageCallback);
      } else {
        const nodeCallback = second;
        return subscribeToLiveStructureShallowly(node, nodeCallback);
      }
    }
    throw new Error(`"${String(first)}" is not a valid event name`);
  }
  return subscribe;
}
function isRoomEventName(value) {
  return value === "my-presence" || value === "others" || value === "event" || value === "error" || value === "connection" || value === "history" || value === "storage-status";
}
var LiveblocksError = class extends Error {
  constructor(message, code) {
    super(message);
    this.code = code;
  }
};
function prepareCreateWebSocket(liveblocksServer, WebSocketPolyfill) {
  if (typeof window === "undefined" && WebSocketPolyfill === void 0) {
    throw new Error(
      "To use Liveblocks client in a non-dom environment, you need to provide a WebSocket polyfill."
    );
  }
  const ws = WebSocketPolyfill || WebSocket;
  return (token) => {
    return new ws(
      `${liveblocksServer}/?token=${token}&version=${// prettier-ignore
      // eslint-disable-next-line @typescript-eslint/ban-ts-comment
      // @ts-ignore (__PACKAGE_VERSION__ will be injected by the build script)
      true ? (
        /* istanbul ignore next */
        "1.0.8"
      ) : "dev"}`
    );
  };
}
function prepareAuthEndpoint(authentication, fetchPolyfill) {
  if (authentication.type === "public") {
    if (typeof window === "undefined" && fetchPolyfill === void 0) {
      throw new Error(
        "To use Liveblocks client in a non-dom environment with a publicApiKey, you need to provide a fetch polyfill."
      );
    }
    return (room) => fetchAuthEndpoint(
      fetchPolyfill || /* istanbul ignore next */
      fetch,
      authentication.url,
      {
        room,
        publicApiKey: authentication.publicApiKey
      }
    );
  }
  if (authentication.type === "private") {
    if (typeof window === "undefined" && fetchPolyfill === void 0) {
      throw new Error(
        "To use Liveblocks client in a non-dom environment with a url as auth endpoint, you need to provide a fetch polyfill."
      );
    }
    return (room) => fetchAuthEndpoint(fetchPolyfill || fetch, authentication.url, {
      room
    });
  }
  if (authentication.type === "custom") {
    return (room) => __async(this, null, function* () {
      const response = yield authentication.callback(room);
      if (!response || !response.token) {
        throw new Error(
          'Authentication error. We expect the authentication callback to return a token, but it does not. Hint: the return value should look like: { token: "..." }'
        );
      }
      return response;
    });
  }
  throw new Error("Internal error. Unexpected authentication type");
}
function fetchAuthEndpoint(fetch2, endpoint, body) {
  return __async(this, null, function* () {
    const res = yield fetch2(endpoint, {
      method: "POST",
      headers: {
        "Content-Type": "application/json"
      },
      // Credentials are needed to support authentication with cookies
      credentials: "include",
      body: JSON.stringify(body)
    });
    if (!res.ok) {
      throw new AuthenticationError(
        `Expected a status 200 but got ${res.status} when doing a POST request on "${endpoint}"`
      );
    }
    let data;
    try {
      data = yield res.json();
    } catch (er) {
      throw new AuthenticationError(
        `Expected a JSON response when doing a POST request on "${endpoint}". ${String(
          er
        )}`
      );
    }
    if (!isPlainObject(data) || typeof data.token !== "string") {
      throw new AuthenticationError(
        `Expected a JSON response of the form \`{ token: "..." }\` when doing a POST request on "${endpoint}", but got ${JSON.stringify(
          data
        )}`
      );
    }
    const { token } = data;
    return { token };
  });
}
var AuthenticationError = class extends Error {
  constructor(message) {
    super(message);
  }
};

// src/client.ts
var MIN_THROTTLE = 16;
var MAX_THROTTLE = 1e3;
var DEFAULT_THROTTLE = 100;
function getServerFromClientOptions(clientOptions) {
  const rawOptions = clientOptions;
  return typeof rawOptions.liveblocksServer === "string" ? rawOptions.liveblocksServer : "wss://api.liveblocks.io/v6";
}
function createClient(options) {
  const clientOptions = options;
  const throttleDelay = getThrottleDelayFromOptions(clientOptions);
  const rooms = /* @__PURE__ */ new Map();
  function getRoom(roomId) {
    const room = rooms.get(roomId);
    return room ? room : null;
  }
  function enter(roomId, options2) {
    var _a, _b, _c;
    const existingRoom = rooms.get(roomId);
    if (existingRoom !== void 0) {
      return existingRoom;
    }
    deprecateIf(
      options2.initialPresence === null || options2.initialPresence === void 0,
      "Please provide an initial presence value for the current user when entering the room."
    );
    const newRoom = createRoom(
      {
        initialPresence: (_a = options2.initialPresence) != null ? _a : {},
        initialStorage: options2.initialStorage
      },
      {
        roomId,
        throttleDelay,
        polyfills: clientOptions.polyfills,
        unstable_batchedUpdates: options2 == null ? void 0 : options2.unstable_batchedUpdates,
        liveblocksServer: getServerFromClientOptions(clientOptions),
        authentication: prepareAuthentication(clientOptions, roomId)
      }
    );
    rooms.set(roomId, newRoom);
    setupDevTools(() => Array.from(rooms.keys()));
    linkDevTools(roomId, newRoom);
    const shouldConnect = (_b = options2.shouldInitiallyConnect) != null ? _b : true;
    if (shouldConnect) {
      if (typeof atob === "undefined") {
        if (((_c = clientOptions.polyfills) == null ? void 0 : _c.atob) === void 0) {
          throw new Error(
            "You need to polyfill atob to use the client in your environment. Please follow the instructions at https://liveblocks.io/docs/errors/liveblocks-client/atob-polyfill"
          );
        }
        global.atob = clientOptions.polyfills.atob;
      }
      newRoom.__internal.connect();
    }
    return newRoom;
  }
  function leave(roomId) {
    unlinkDevTools(roomId);
    const room = rooms.get(roomId);
    if (room !== void 0) {
      room.__internal.disconnect();
      rooms.delete(roomId);
    }
  }
  if (typeof window !== "undefined" && // istanbul ignore next: React Native environment doesn't implement window.addEventListener
  typeof window.addEventListener !== "undefined") {
    window.addEventListener("online", () => {
      for (const [, room] of rooms) {
        room.__internal.onNavigatorOnline();
      }
    });
  }
  if (typeof document !== "undefined") {
    document.addEventListener("visibilitychange", () => {
      for (const [, room] of rooms) {
        room.__internal.onVisibilityChange(document.visibilityState);
      }
    });
  }
  return {
    getRoom,
    enter,
    leave
  };
}
function getThrottleDelayFromOptions(options) {
  if (options.throttle === void 0) {
    return DEFAULT_THROTTLE;
  }
  if (typeof options.throttle !== "number" || options.throttle < MIN_THROTTLE || options.throttle > MAX_THROTTLE) {
    throw new Error(
      `throttle should be a number between ${MIN_THROTTLE} and ${MAX_THROTTLE}.`
    );
  }
  return options.throttle;
}
function prepareAuthentication(clientOptions, roomId) {
  const { publicApiKey, authEndpoint } = clientOptions;
  if (authEndpoint !== void 0 && publicApiKey !== void 0) {
    throw new Error(
      "You cannot use both publicApiKey and authEndpoint. Please use either publicApiKey or authEndpoint, but not both. For more information: https://liveblocks.io/docs/api-reference/liveblocks-client#createClient"
    );
  }
  if (typeof publicApiKey === "string") {
    if (publicApiKey.startsWith("sk_")) {
      throw new Error(
        "Invalid publicApiKey. You are using the secret key which is not supported. Please use the public key instead. For more information: https://liveblocks.io/docs/api-reference/liveblocks-client#createClientPublicKey"
      );
    } else if (!publicApiKey.startsWith("pk_")) {
      throw new Error(
        "Invalid key. Please use the public key format: pk_<public key>. For more information: https://liveblocks.io/docs/api-reference/liveblocks-client#createClientPublicKey"
      );
    }
    return {
      type: "public",
      publicApiKey,
      url: buildLiveblocksPublicAuthorizeEndpoint(clientOptions, roomId)
    };
  }
  if (typeof authEndpoint === "string") {
    return {
      type: "private",
      url: authEndpoint
    };
  } else if (typeof authEndpoint === "function") {
    return {
      type: "custom",
      callback: authEndpoint
    };
  } else if (authEndpoint !== void 0) {
    throw new Error(
      "authEndpoint must be a string or a function. For more information: https://liveblocks.io/docs/api-reference/liveblocks-client#createClientAuthEndpoint"
    );
  }
  throw new Error(
    "Invalid Liveblocks client options. For more information: https://liveblocks.io/docs/api-reference/liveblocks-client#createClient"
  );
}
function buildLiveblocksPublicAuthorizeEndpoint(options, roomId) {
  if (options.publicAuthorizeEndpoint) {
    return options.publicAuthorizeEndpoint.replace("{roomId}", roomId);
  }
  return `https://api.liveblocks.io/v2/rooms/${encodeURIComponent(
    roomId
  )}/public/authorize`;
}

// src/immutable.ts
function lsonObjectToJson(obj) {
  const result = {};
  for (const key in obj) {
    const val = obj[key];
    if (val !== void 0) {
      result[key] = lsonToJson(val);
    }
  }
  return result;
}
function liveObjectToJson(liveObject) {
  return lsonObjectToJson(liveObject.toObject());
}
function liveMapToJson(map) {
  const result = {};
  for (const [key, value] of map.entries()) {
    result[key] = lsonToJson(value);
  }
  return result;
}
function lsonListToJson(value) {
  return value.map(lsonToJson);
}
function liveListToJson(value) {
  return lsonListToJson(value.toArray());
}
function lsonToJson(value) {
  if (value instanceof LiveObject) {
    return liveObjectToJson(value);
  } else if (value instanceof LiveList) {
    return liveListToJson(value);
  } else if (value instanceof LiveMap) {
    return liveMapToJson(value);
  } else if (value instanceof LiveRegister) {
    return value.data;
  }
  if (Array.isArray(value)) {
    return lsonListToJson(value);
  } else if (isPlainObject(value)) {
    return lsonObjectToJson(value);
  }
  return value;
}
function deepLiveify(value) {
  if (Array.isArray(value)) {
    return new LiveList(value.map(deepLiveify));
  } else if (isPlainObject(value)) {
    const init = {};
    for (const key in value) {
      const val = value[key];
      if (val === void 0) {
        continue;
      }
      init[key] = deepLiveify(val);
    }
    return new LiveObject(init);
  } else {
    return value;
  }
}
function patchLiveList(liveList, prev, next) {
  let i = 0;
  let prevEnd = prev.length - 1;
  let nextEnd = next.length - 1;
  let prevNode = prev[0];
  let nextNode = next[0];
  outer: {
    while (prevNode === nextNode) {
      ++i;
      if (i > prevEnd || i > nextEnd) {
        break outer;
      }
      prevNode = prev[i];
      nextNode = next[i];
    }
    prevNode = prev[prevEnd];
    nextNode = next[nextEnd];
    while (prevNode === nextNode) {
      prevEnd--;
      nextEnd--;
      if (i > prevEnd || i > nextEnd) {
        break outer;
      }
      prevNode = prev[prevEnd];
      nextNode = next[nextEnd];
    }
  }
  if (i > prevEnd) {
    if (i <= nextEnd) {
      while (i <= nextEnd) {
        liveList.insert(deepLiveify(next[i]), i);
        i++;
      }
    }
  } else if (i > nextEnd) {
    let localI = i;
    while (localI <= prevEnd) {
      liveList.delete(i);
      localI++;
    }
  } else {
    while (i <= prevEnd && i <= nextEnd) {
      prevNode = prev[i];
      nextNode = next[i];
      const liveListNode = liveList.get(i);
      if (isLiveObject(liveListNode) && isPlainObject(prevNode) && isPlainObject(nextNode)) {
        patchLiveObject(liveListNode, prevNode, nextNode);
      } else {
        liveList.set(i, deepLiveify(nextNode));
      }
      i++;
    }
    while (i <= nextEnd) {
      liveList.insert(deepLiveify(next[i]), i);
      i++;
    }
    let localI = i;
    while (localI <= prevEnd) {
      liveList.delete(i);
      localI++;
    }
  }
}
function patchLiveObjectKey(liveObject, key, prev, next) {
  if (process.env.NODE_ENV !== "production") {
    const nonSerializableValue = findNonSerializableValue(next);
    if (nonSerializableValue) {
      error(
        `New state path: '${nonSerializableValue.path}' value: '${String(
          nonSerializableValue.value
        )}' is not serializable.
Only serializable value can be synced with Liveblocks.`
      );
      return;
    }
  }
  const value = liveObject.get(key);
  if (next === void 0) {
    liveObject.delete(key);
  } else if (value === void 0) {
    liveObject.set(key, deepLiveify(next));
  } else if (prev === next) {
    return;
  } else if (isLiveList(value) && Array.isArray(prev) && Array.isArray(next)) {
    patchLiveList(value, prev, next);
  } else if (isLiveObject(value) && isPlainObject(prev) && isPlainObject(next)) {
    patchLiveObject(value, prev, next);
  } else {
    liveObject.set(key, deepLiveify(next));
  }
}
function patchLiveObject(root, prev, next) {
  const updates = {};
  for (const key in next) {
    patchLiveObjectKey(root, key, prev[key], next[key]);
  }
  for (const key in prev) {
    if (next[key] === void 0) {
      root.delete(key);
    }
  }
  if (Object.keys(updates).length > 0) {
    root.update(updates);
  }
}
function getParentsPath(node) {
  const path = [];
  while (node.parent.type === "HasParent") {
    if (isLiveList(node.parent.node)) {
      path.push(node.parent.node._indexOfPosition(node.parent.key));
    } else {
      path.push(node.parent.key);
    }
    node = node.parent.node;
  }
  return path;
}
function legacy_patchImmutableObject(state, updates) {
  return updates.reduce(
    (state2, update) => legacy_patchImmutableObjectWithUpdate(state2, update),
    state
  );
}
function legacy_patchImmutableObjectWithUpdate(state, update) {
  const path = getParentsPath(update.node);
  return legacy_patchImmutableNode(state, path, update);
}
function legacy_patchImmutableNode(state, path, update) {
  var _a, _b, _c, _d;
  const pathItem = path.pop();
  if (pathItem === void 0) {
    switch (update.type) {
      case "LiveObject": {
        if (!isJsonObject(state)) {
          throw new Error(
            "Internal: received update on LiveObject but state was not an object"
          );
        }
        const newState = Object.assign({}, state);
        for (const key in update.updates) {
          if (((_a = update.updates[key]) == null ? void 0 : _a.type) === "update") {
            const val = update.node.get(key);
            if (val !== void 0) {
              newState[key] = lsonToJson(val);
            }
          } else if (((_b = update.updates[key]) == null ? void 0 : _b.type) === "delete") {
            delete newState[key];
          }
        }
        return newState;
      }
      case "LiveList": {
        if (!Array.isArray(state)) {
          throw new Error(
            "Internal: received update on LiveList but state was not an array"
          );
        }
        let newState = state.map((x) => x);
        for (const listUpdate of update.updates) {
          if (listUpdate.type === "set") {
            newState = newState.map(
              (item, index) => index === listUpdate.index ? lsonToJson(listUpdate.item) : item
            );
          } else if (listUpdate.type === "insert") {
            if (listUpdate.index === newState.length) {
              newState.push(lsonToJson(listUpdate.item));
            } else {
              newState = [
                ...newState.slice(0, listUpdate.index),
                lsonToJson(listUpdate.item),
                ...newState.slice(listUpdate.index)
              ];
            }
          } else if (listUpdate.type === "delete") {
            newState.splice(listUpdate.index, 1);
          } else if (listUpdate.type === "move") {
            if (listUpdate.previousIndex > listUpdate.index) {
              newState = [
                ...newState.slice(0, listUpdate.index),
                lsonToJson(listUpdate.item),
                ...newState.slice(listUpdate.index, listUpdate.previousIndex),
                ...newState.slice(listUpdate.previousIndex + 1)
              ];
            } else {
              newState = [
                ...newState.slice(0, listUpdate.previousIndex),
                ...newState.slice(
                  listUpdate.previousIndex + 1,
                  listUpdate.index + 1
                ),
                lsonToJson(listUpdate.item),
                ...newState.slice(listUpdate.index + 1)
              ];
            }
          }
        }
        return newState;
      }
      case "LiveMap": {
        if (!isJsonObject(state)) {
          throw new Error(
            "Internal: received update on LiveMap but state was not an object"
          );
        }
        const newState = Object.assign({}, state);
        for (const key in update.updates) {
          if (((_c = update.updates[key]) == null ? void 0 : _c.type) === "update") {
            const value = update.node.get(key);
            if (value !== void 0) {
              newState[key] = lsonToJson(value);
            }
          } else if (((_d = update.updates[key]) == null ? void 0 : _d.type) === "delete") {
            delete newState[key];
          }
        }
        return newState;
      }
    }
  }
  if (Array.isArray(state)) {
    const newArray = [...state];
    newArray[pathItem] = legacy_patchImmutableNode(
      state[pathItem],
      path,
      update
    );
    return newArray;
  } else if (isJsonObject(state)) {
    const node = state[pathItem];
    if (node === void 0) {
      return state;
    } else {
      const stateAsObj = state;
      return __spreadProps(__spreadValues({}, stateAsObj), {
        [pathItem]: legacy_patchImmutableNode(node, path, update)
      });
    }
  } else {
    return state;
  }
}

// src/lib/shallow.ts
function shallowArray(xs, ys) {
  if (xs.length !== ys.length) {
    return false;
  }
  for (let i = 0; i < xs.length; i++) {
    if (!Object.is(xs[i], ys[i])) {
      return false;
    }
  }
  return true;
}
function shallowObj(objA, objB) {
  if (typeof objA !== "object" || objA === null || typeof objB !== "object" || objB === null || Object.prototype.toString.call(objA) !== "[object Object]" || Object.prototype.toString.call(objB) !== "[object Object]") {
    return false;
  }
  const keysA = Object.keys(objA);
  if (keysA.length !== Object.keys(objB).length) {
    return false;
  }
  return keysA.every(
    (key) => Object.prototype.hasOwnProperty.call(objB, key) && Object.is(objA[key], objB[key])
  );
}
function shallow(a, b) {
  if (Object.is(a, b)) {
    return true;
  }
  const isArrayA = Array.isArray(a);
  const isArrayB = Array.isArray(b);
  if (isArrayA || isArrayB) {
    if (!isArrayA || !isArrayB) {
      return false;
    }
    return shallowArray(a, b);
  }
  return shallowObj(a, b);
}




































exports.ClientMsgCode = ClientMsgCode; exports.CrdtType = CrdtType; exports.LiveList = LiveList; exports.LiveMap = LiveMap; exports.LiveObject = LiveObject; exports.OpCode = OpCode; exports.ServerMsgCode = ServerMsgCode; exports.WebsocketCloseCodes = WebsocketCloseCodes; exports.asArrayWithLegacyMethods = asArrayWithLegacyMethods; exports.asPos = asPos; exports.assert = assert; exports.assertNever = assertNever; exports.b64decode = b64decode; exports.createClient = createClient; exports.deprecate = deprecate; exports.deprecateIf = deprecateIf; exports.errorIf = errorIf; exports.freeze = freeze; exports.isAppOnlyAuthToken = isAppOnlyAuthToken; exports.isAuthToken = isAuthToken; exports.isChildCrdt = isChildCrdt; exports.isJsonArray = isJsonArray; exports.isJsonObject = isJsonObject; exports.isJsonScalar = isJsonScalar; exports.isPlainObject = isPlainObject; exports.isRoomAuthToken = isRoomAuthToken; exports.isRootCrdt = isRootCrdt; exports.legacy_patchImmutableObject = legacy_patchImmutableObject; exports.lsonToJson = lsonToJson; exports.makePosition = makePosition; exports.nn = nn; exports.patchLiveObjectKey = patchLiveObjectKey; exports.shallow = shallow; exports.throwUsageError = throwUsageError; exports.tryParseJson = tryParseJson;
